---
title: HTTP (1-1) - HTTP 버전 별 특징 (0.9 / 1.0 / 1.1)
description: HTTP의 버전(0.9 / 1.0 / 1.1)에 대한 특징과 차이점에 대한 정리
categories: [Computer Science, Network]
tags: [computer-science, network, http] # TAG names should always be lowercase
pin: false
math: true
mermaid: true
published: false
private: false # 커스텀해서 만든 것
image-path: /assets/img/computer-science/network/http/http-1-1 # 이미지 공통 경로 변수
image:
  path: /assets/img/computer-science/network/http/http-1-1/http-1-1_1.png
  lqip: data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=
  alt: HTTP(Hyper Text Transfer Protocol)'s History
---

## HTTP(Hyper Text Transfer Protocol)란?

`HTTP`(Hyper Text Transfer Protocol)는 상당한 범위의 기능 확장이 가능하며 `HTML` 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다.

`HTTP`는 웹에서 이루어지는 모든 데이터 교환의 기초이며, 클라이언트-서버 프로토콜이기도 하다.

> - 클라이언트-서버 프로토콜
>   : (보통 웹 브라우저인) 수신자 측에 의해 요청이 초기화되는 프로토콜을 의미한다.
>   : 하나의 완전한 문서는 텍스트, 레이아웃 설명, 이미지, 비디오, 스크립트 등을 불러온(`fetched`) 하위 문서들로 재구성된다.

또한 `HTTP`를 이용한 데이터 전달은 `TCP` 세션 기반에서 이루어진다. (Application 층에 존재)

이러한 `HTTP`는 여러 과정을 거쳐 현재의 웹의 표준으로 자리잡게 되었는데, 아래의 내용을 통해 `HTTP`의 역사와 함께 변천 과정에 대해 알아보고 `HTTP`에 적용된 기술에 대해 정리할 예정이다.

## HTTP 버전의 역사

![image_5][image_5]

`HTTP`의 역사는 위와 같다.

`HTTP`의 시작은 1989년 팀 버너 리(Tim Berners-LEE)에 의해 제안된 인터넷의 하이퍼 텍스트 시스템이다.

## HTTP/0.9 (1991, One-Line Protocol)

{: file="Request"}

```http
GET /mypage.html
```

{: file="Response"}

```html
<html>
  A very simple HTML page
</html>
```

`HTTP/0.9`는 One-Line Protocol로, 요청은 단일 라인으로 구성되며 리소스에 대한 Method는 `GET`만 존재한다.

응답 역시도 파일 내용 자체로만 구성되어 있어 극도로 단순한 것이 특징이다.

`HTTP`의 헤더가 없고, 오로지 `HTML` 파일만 전송이 가능했으며 상태 혹은 오류 코드가 없었으며, 문제가 발생한 경우에는 특정 `HTML` 파일을 오류에 대한 설명과 함께 보내졌다.

- HTTP/0.9 스펙 정리
  : `TCP/IP` 링크 위에서 동작하는 `ASCII` 프로토콜
  : `GET` 메서드만 지원
  : `HTTP` 헤더 X, 상태 코드 X
  : 응답도 `HTML` 파일 자체만 보내줌
  : 서버와 클라이언트 간의 연결은 모든 요청 후에 당힘

## HTTP/1.0 (1996)

인터넷이 빠르게 성장하면서 1994년 <ins>W3C</ins>[^w3c]가 만들어지면서 `HTML`의 발전을 도모하게 되었고 이와 비슷하게 `HTTP` 프로토콜 개선에도 초점을 맞추기 위해 <ins>HTTP-WG(HTTP Working Group)</ins>가 설립되었다.

웹 브라우저, 인터넷 인프라가 빠르게 진화하며 이제는 단순히 하이퍼 텍스트 문서 뿐만이 아닌, 멀티 미디어 데이터나 메타 데이터 등 다양하고 상세한 컨텐츠가 필요해짐으로써, 기존의 HTTP/0.9로는 다양한 요구사항들을 채울 수 없는 한계에 봉착하게 되었다.

그러던 중에 1996년 HTTP-WG는 HTTP/1.0 구현의 일반적인 사용을 문서화한 <ins>RFC 1945</ins>를 발표한다.

### HTTP/1.0의 특징

{: .prompt-info}

> RFC 1945는 어려울 것 없이 HTTP/1.0 프로토콜 통신 스펙에 관한 기술 문서 정도로 이해하면 된다.
>
> 컨텐츠 인코딩, 다양한 글자 지원, 멀티파트 타입, 인가, 캐싱, 프록시, 날짜 형식 등을 문서화했다.

이는 아래와 같은 굉장히 익숙한 형태의 요청과 응답 포맷으로 구성되었다.

{: file="Request"}

```http
GET /mypage.html HTTP/1.0
User-Agent: NCSA_Mosaic/2.0 (Windows 3.1)
```

{: file="Response"}

```html
200 OK Date: Tue, 15 Nov 1994 08:12:31 GMT Server: CERN/3.0 libwww/2.17
Content-Type: text/html

<html>
  A page with an image
  <img src="/myimage.gif" />
</html>
```

Request 메시지에는 `GET` 요청이 시작되는 줄에 `PATH`와 `HTTP` 버전, 그리고 다음 줄로 이어지는 헤더 값을 가지며, Response 메시지에는 `200 OK` 이후 응답 상태로 이어지는 응답 헤더 값을 가지는 것을 볼 수 있다.

이와 같이 HTTP/1.0은 이른바 `HTTP` 포맷 형태의 시초라고 보면 된다.

- HTTP/1.0 스펙 정리
  : 기본적인 `HTTP` 메서드와 요청/응답 헤더 추가
  : `HTTP` 버전 정보가 각 요청 사이 내로 전송되기 시작 (HTTP/1.0이 `GET` 라인에 붙는 형태)
  : 상태 코드(Status Code)가 응답의 시작 부분에 붙어서 전송되며, 브라우저가 요청에 대한 성공과 실패를 알 수 있고 그 결과에 대한 동작을 할 수 있게 되었다. (특정 방법으로 로컬 캐시를 갱신하거나 하는 등...)
  : 응답 헤더의 `Content-Type` 덕분에 `HTML` 파일 형식 외에 다른 문서들을 전송하는 기능이 추가되었다.
  : 단기 커넥션
  : - Connection 하나 당, 1 Request & 1 Response 처리 가능

### HTTP/1.0의 문제점

#### Short-lived Connection

![image_6][image_6]

HTTP/1.0의 문제점은 비연결성(Connectionless)로 인한 단기 커넥션(Short-lived Connection) 특징이다.

즉, 커넥션 하나 당, 하나의 요과 하나의 응답 처리가 가능한 것을 말하는데, 서버에 자원을 요청할 때마다 매번 새로운 연결을 해줘야 했다.

- 1 Request & 1 Response
- 매번 새로운 연결로 인한 성능 저하
- 매번 새로운 연결로 서버 부하 비용 증가

예를 들어, 웹 페이지를 요청하면 `HTML`과 그에 딸린 `CSS`나 `JavaScript` 및 이미지 등의 수많은 자원들이 다운로드되고 화면에 띄워지는데 각 자원들을 매번 따로 `TCP` 연결하고 다운받고 연결 끊고 하는 과정을 자원만큼 반복하는 것이다.

그래서 `HTTP` 초기에는 모든 자료에 대해서 비연결성으로 각각의 자원에 대해 연결 → 응답 → 종료를 반복하다보니, 느렸다.

## HTTP/1.1 (표준 프로토콜의 등장, 1997)

HTTP/1.0의 몇 가지 단점을 보완하기 위해 HTTP/1.0이 출시된지 얼마 안된 <ins>6개월</ins> 만인 1997년 1월에 공식적으로 HTTP/1.1이 발표된다.

현재 가장 많이 쓰이는 프로토콜 버전으로, 우리가 `HTTP`를 학습할 때 배우는 가장 기본이 되는 지식이다.

HTTP/1.1 표준은 이전 버전에서 발견된 많은 프로토콜의 모호성을 해결하고 몇 가지 중요한 성능 개선을 도입했다.

- HTTP/1.1에서 보완된 특징
  : 지속 연결 (Persistent Connection)
  : - 지정한 `timeout` 동안 연속적인 요청 사이에 커넥션을 닫지 않으며, 기존 연결에 대해서 `handshake` 생략이 가능
- 파이프라이닝 (Pipelining) → <ins class="red">현재 불안정하여 사장됨</ins>
  : 이전 요청에 대한 응답이 완전히 전송되기 전에 다음 전송을 가능하게 하여 여러 요청을 연속적으로 보내 그 순서에 맞춰 응답을 받는 방식으로 지연 시간을 줄인 방식
- `Host` 헤더 추가
  : 동일한 `IP` 주소에 다른 도메인을 호스트 가능
- Chunk Encoding 전송
  : 응답 조각
- 기타 보완된 점
  : 바이트 범위 요청
  : 캐시 제어 메커니즘 도입

### Persistent Connetion (keep-alive)

`HTTP`는 `TCP` 연결 기반 위에서 동작하는 프로토콜로 신뢰성 확보를 위해 연결을 맺고 끊는 데 있어서 [#TCP VS UDP - 3-Way Handshake][3-way]가 이뤄진다.

그런데 `HTTP`는 기본적으로 비연결성(Connectionless) 프로토콜이기 때문에 한번의 요청과 응답을 하고 응답이 끝나면 연결을 끊어버리는데, 자원을 요청할 때마다 연결을 맺고 끊어버려서 오버헤드[^overhead]가 생기게 된다.

이러한 현상을 보완하기 위해 HTTP/1.1에서 <ins>Persistent Connection</ins> 기능이 추가됨으로써, <ins>한 번 맺어졌던 연결을 끊지 않고 지속적으로 유지</ins>해 불필요한 Handshake를 줄여 성능을 개선하였다.

![image_7][image_7]

- 연결을 유지함으로써 Handshake 과정을 생략해 빠르게 자원을 받아올 수 있다.
- 불필요한 연결의 맺고 끊음을 최소화시켜 네트워크 부하를 줄일 수 있다.
- 클라이언트 측에서 요청에 `keep-alive` 헤더를 담아 보내야 한다.
- 정확한 `Content-length` 헤더를 사용해야 한다.
- 하나의 Connection을 계속해서 재사용해야 하는데, 특정 요청의 종료를 판단할 수 없기 때문이다.
- Connection 헤더를 지원하지 않은 `Proxy`에는 사용할 수 없다.

{: .prompt-info}

> 가끔 `HTTP` 지속 연결을 Persistent Connection 혹은 keep-alive Connection으로 용어를 혼용하는 경우가 있는데, 정확히는 Persistent Connection이 맞다.
>
> keep-alive는 HTTP/1.0+ 버전이 Persistent Connection을 연결하기 위해 헤더에 명시해 사용하는 단어라고 보면 된다.

#### keep-alive 동작 과정

{: file="Request"}

```http
GET /index.html HTTP/1.1
Host: website.org
Connection: keep-alive
```

{: file="Response"}

```bash
HTTP/1.1 200 OK
Date: Sat, 10 Aug 2024 07:48:28 GMT
Server: Apache/2.4.48 (Ubuntu)
Cache-Control: no-cache, private
Set-Cookie: ...
Vary: Accept-Encoding
Content-Encoding: gzip
Content-Length: 44498
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html; charset=UTF-8
```

## 참고 사이트

> [드프 DrawingProcess - [Network] HTTP 버전 별 특징: HTTP v0.9 v1.0 v1.1 v2 v3][ref_site_2]
>
> [Semantics - HTTP (1) - version 별 특징 (0.9 / 1.0 / 2.0 / 3.0)][ref_site_3]
>
> [minu.log - HTTP/1.0, HTTP/1.1, HTTP/2.0, HTTP/3.0, and QUIC][ref_site_4]
>
> [Inpa Dev - 🌐 HTTP 0.9 ~ HTTP 1.1 까지 알아보는 통신 기술][ref_site_4]

---

[^w3c]: 월드 와이드 웹을 위한 표준을 개발하고 장려하는 조직으로 팀 버너스리를 중심으로 1994년 10월에 설립되었으며, W3C는 회원기구, 정직원, 공공기관이 협력하여 웹 표준을 개발하는 국제 컨소시엄이다.
[^overhead]: 오버헤드(Overhead)는 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.

<!-- 이미지 -->

[image_1]: {{page.image-path}}/http-1-1_1.png
[image_2]: {{page.image-path}}/http-1-1_2.png
[image_3]: {{page.image-path}}/http-1-1_3.png
[image_4]: {{page.image-path}}/http-1-1_4.png
[image_5]: {{page.image-path}}/http-1-1_5.png
[image_6]: {{page.image-path}}/http-1-1_6.png
[image_7]: {{page.image-path}}/http-1-1_7.png

<!-- 블로그 게시글 -->

[3-way]: {{site.url}}/posts/tcp-udp/#3-way-handshake의-과정

<!-- 참고 사이트 -->

[ref_site_1]: https://mangkyu.tistory.com/98
[ref_site_2]: https://csj000714.tistory.com/733
[ref_site_3]: https://velog.io/@neity16/HTTP-HTTP-%EB%B2%84%EC%A0%84-%EB%B3%84-%ED%8A%B9%EC%A7%95
[ref_site_4]: https://velog.io/@minu/HTTP1.0-HTTP1.1-HTTP2-and-QUIC
[ref_site_5]: https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-09-HTTP-30-%EA%B9%8C%EC%A7%80-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0#http_1.1%EC%9D%84_%EA%B0%9C%EC%84%A0%ED%95%9C_http_2.0
