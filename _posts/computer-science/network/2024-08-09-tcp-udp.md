---
title: TCP VS UDP
description: TCP와 UDP를 비교하여 개념을 정리
categories: [Computer Science, Network]
tags: [computer-science, network, udp, tcp] # TAG names should always be lowercase
pin: false
math: true
mermaid: true
published: true
private: true # 커스텀해서 만든 것
image-path: /assets/img/computer-science/network/tcp-udp # 이미지 공통 경로 변수
image:
  path: /assets/img/computer-science/network/tcp-udp/tcp-udp_3.png
  lqip: data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=
  alt: UDP(User Datagram Protocol) VS TCP(Transmission Control Protocol)
---

## Protocol(프로토콜)?

{: .prompt-info}

> 결론을 먼저 말하자면, `HTTP`, `IP`, `TCP`, `UDP` 모두 프로토콜이며, 프로토콜은 클라이언트와 서버가 <ins>정보를 교환하기 위한 일종의 메시지 형식의 규칙</ins>이다.

<ins>프로토콜(Protocol)</ins>은 클라이언트와 서버가 정보를 교환할 수 있도록 하는 <ins>메시지 형식에 대한 규칙</ins>이라고 보면 된다.

수신 호스트가 전송받은 메시지를 이해하기 위해서는 설계된 규칙에 따라 작성된 데이터 형식이어야 한다는 것이다.

예를 들어 `HTTP` 메시지 헤더도 결국 일종의 규칙이며, `IP` 주소의 숫자도 규칙이라고 말할 수 있다.

> `IP`의 규칙을 깨는 `256.256.256.256`과 같은 형식의 `IP` 주소는 존재하지도 않으며, 작동하지도 않는다.

## TCP (Transmission Control Protocol, 전송 제어 프로토콜)

`IP`(Internet Protocol)가 인터넷 프로토콜로서 복잡한 <ins>인터넷 망 속에서 클라이언트와 서버 간의 통신</ins>을 할 수 있게 `IP` 주소, 패킷과 같은 규칙을 통해 통신을 하는 것이라면,

`TCP`(Transmission Control Protocol)는 `IP` 규칙으로만 통신하기에 부족하거나 불안정하던 여러 단점들(패킷 순서가 이상하거나 패킷이 유실)을 커버해, <ins>패킷 전송을 제어하여 신뢰성을 보증</ins>하는 프로토콜로 보면 된다.

`IP`와 `TCP` 둘 다 프로토콜이지만 이 둘을 동일시하면 안되는게, 이 둘의 규칙은 별개이다.

`IP` 규칙으로 써있는대로 목적지에 도착했으면 `TCP` 규칙으로 써있는대로 올바르게 도착했는지, 정확히 누구에게 전달되어야 하는지 등 하나씩 전부 따진다고 생각하면 된다.

> 그래서 은행 업무나 메일과 같은 반드시 수신자가 정보를 받아야 하는 신뢰성 있는 통신이 필요할 때 사용된다.

### TCP의 전송 데이터 포장

![image_4][image_4]

`TCP`의 인터넷 통신을 위한 전송 데이터 포장 방식은 위의 이미지와 같다.

추가적인 예시를 들자면, 택배 수화물로 비유할 수 있다.

`IP`는 단순히 배달 주소지라고 한다면, `TCP`는 이 배달지로 문제없이 전송되도록 택배 스티커와 같은 여러 부가 정보들을 가미한 것이라고 볼 수 있다.

단순히 목적지 뿐만 아니라 순서, 검증, 전송 제어 정보가 들어있어 `IP` 주소지로만 물품을 배달하기엔 불안정한 부분들을 확실하게 커버하여 배달품이 목적지까지 안전하게 도착하도록 보증한다.

![image_5][image_5]

위의 이미지는 전송 데이터가 포장되는 과정을 나열한 것이다.

1. 전송 데이터를 `TCP` 방식으로 포장한다.
2. 포장한 전송 데이터를 `IP` 방식으로 포장한다.
3. 포장한 전송 데이터를 `Ethernet` 방식으로 포장한다.
4. 인터넷을 통해 상대 컴퓨터 서버에 도달하여 포장된 것을 하나씩 풀며 전송 데이터를 받게 된다.

### TCP의 통신 확인

`TCP`는 신뢰성 프로토콜답게, 데이터를 전송하기 전에 목적지가 무사한지를 미리 확인하고, 데이터의 전송이 끝난 후에도 다시 확인 해주는 굉장히 친절하고 꼼꼼한 프로토콜이다.

통신을 시작할 때와 종료할 때 서로 준비가 되어있는지를 반드시 미리 먼저 물어보고 패킷을 전송할 순서를 정하고 나서야 본격적으로 통신을 시작하기 때문이다.

이러한 과정이 바로 <ins>3-Way Handshake</ins>와 <ins>4-Way Handshake</ins> 과정이다.

둘 다 똑같은 핸드쉐이크(Handshake)지만, <ins class="blue">3-Way</ins>는 통신을 시작할 때, <ins class="red">4-Way</ins>는 통신이 종료될 때 거치는 과정이라는 차이만 있다.

즉, 한 번 통신하는데 핸드쉐이크를 두 번 진행해서 과할 정도로 신뢰성을 보장한다고 생각하면 된다.

![image_6][image_6]

위의 이미지에서 클라이언트가 처음 서버와 통신을 하기 위해 `TCP` 연결을 생성할 때, <ins>SYN</ins>와 <ins>ACK</ins>라는 패킷을 주고 받으며, 통신을 종료하는 과정에서는 <ins>FIN</ins>이라는 패킷을 주고 받고 있는 것 볼 수 있다.

즉, 패킷 내부에 들어있는 인증 플래그 값들을 확인해서 클라이언트와 서버가 서로 보낸 패킷의 순서와 패킷을 제대로 받았는지를 검증하는 것이다.

#### Flag 종류

| FLAG  | 설명                                                                                                              |
| :---: | ----------------------------------------------------------------------------------------------------------------- |
| `SYN` | 접속 요청을 할 때 보내는 패킷을 말한다.<br />`TCP` 접속 시에 가장 먼저 보내는 패킷이다.                           |
| `ACK` | 상대방으로부터 패킷을 받은 뒤에 잘 받았다고 알려주는 패킷을 말한다.<br />다른 플래그와 같이 출력되는 경우도 있다. |
| `PSH` | 데이터를 즉시 목적지로 보내라는 의미이다.                                                                         |
| `FIN` | 접속 종료를 위한 플래그이다.<br />이 패킷을 보내는 곳이 현재 접속하고 있는 곳과 접속을 끊고자 할 때 사용한다.     |

#### 3-Way Handshake의 과정

![image_7][image_7]

1. 클라이언트는 접속을 요청하는 `SYN` 패킷을 보낸다.

   이때, 클라이언트는 응답을 기다리기 위해 `SYN_SENT` 상태로 변한다.

2. `LISTEN` 상태였던 서버는 `SYN` 요청을 받으면, 클라이언트에게 요청을 수락하는 `ACK` 패킷과 `SYN` 패킷을 보낸다.

   > 서버도 클라이언트에 접속해야 양방향 통신이 되기 때문이다.

   그리고 `SYN_RCVD(SYN_RECEIVED)` 상태로 변하여 클라이언트가 `ACK` 패킷을 보낼 때까지 기다리게 된다.

3. 클라이언트는 다시 서버에 `ACK` 패킷을 보내고, 이후에 `ESTABLISHED` 상태가 되어 데이터 통신이 가능하게 된다.

#### 데이터 통신 과정

![image_8][image_8]

1. `ESTABLISHED`된 상태에서 서버에게 데이터를 보낸다.
2. 서버는 잘 전송받았다고 `ACK` 플래스를 넣어 응답한다.
3. 만약 클라이언트가 서버로부터 `ACK`를 받지 못했다면, 제대로 송신하지 못한걸로 판단하고 데이터를 재전송한다.

#### 4-Way Handshake의 과정

![image_9][image_9]

1. 서버와 클라이언트가 `TCP` 연결이 되어있는 상태에서 클라이언트가 접속을 끊기 위해 `CLOSE()` 함수를 호출한다.

   그러면 `FIN` 플래그를 보내게 되고, 클라이언트는 `FIN_WAIT1` 상태로 변한다.

2. 서버는 클라이언트가 `CLOSE()` 함수를 호출한 것을 알게되고, `CLOSE_WAIT` 상태로 바꾼 후, `ACK` 플래그를 전송한다.

   만일 서버에서 클라이언트로 보내야 하는 남은 데이터가 있을 경우, 이 과정에서 나머지를 모두 전송시킨다.

3. `ACK`를 받은 클라이언트는 `FIN_WAIT2`로 변환되고, 이떄 서버는 `CLOSE()` 함수를 호출하고 `FIN` 플래그를 클라이언트에게 보낸다.
4. 서버도 연결을 닫았다는 신호를 클라이언트가 수신하면, `ACK` 플래그를 보낸 후 `TIME_WAIT` 상태로 전환된다.

   이 후, 모든 것이 끝나면 `CLOSED` 상태로 변환된다.

### TCP 통신 과정 시각적으로 확인하기

`TCP` 핸드쉐이크 과정을 시각적으로 확인하기 위해 Linux 명령어를 통해 진행할 예정이다.

> <https://www.wireshark.org/> → 와이어샤크라는 무료 소프트웨어를 사용해서 확인하는 방법도 있다.

#### Linux tcpdump로 확인하기

`tcpdump`는 Linux 환경에서 클라이언트와 서버가 주고받는 네트워크 패킷을 `TCP layer`에서 캡쳐하여 메시지를 확인할 수 있는 명령어로, `UDP`도 확인이 가능하다.

먼저 아래의 명령어를 통해 `tcpdump` 명령어를 설치한다.

> 필자의 맥 세팅의 경우, Homebrew를 통해 설치를 진행

```bash
# 우분투 설치
apt install tcpdump

# CentOS 설치
yum install tcpdump

# Homebrew 설치
brew install tcpdump
```

위의 명령어를 통해 설치가 끝났다면, 아래의 명령어를 실행한다.

```bash
# 인터넷 통신을 하는 모든 프로토콜 감지 명령어
sudo tcpdump -i en1 -c 10 # MacOS의 경우, sudo
```

- `-i <interface>`
  : 인터페이스 지정
- `-c <count>`
  : 지정한 카운트 패킷을 수신한 후 종료

> en1 등의 네트워크를 알고 싶다면 "이 Mac에 관하여" → "추가 정보" → 맨 아래의 "시스템 리포트" → "네트워크"

위와 같이 옵션을 지정해서 명령어를 실행하면,

{: file="result"}

```bash
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on en1, link-type EN10MB (Ethernet), snapshot length 262144 bytes
```

위와 같이 인터넷 통신을 감지하는 상태가 되고, 인터넷 통신이 감지가 된다면,

{: file="result"}

```bash
14:34:53.316116 IP XXX.XX.X.X.mdns > mdns.mcast.net.mdns: 0*- [0q] 2/0/0 PTR _airplay._tcp.local., PTR _raop._tcp.local. (88)
```

위와 같은 네트워크 통신 로그를 볼 수 있다.

그렇다면 직접 통신을 진행시키고 로그를 확인해보도록 한다.

1.  80번 포트로 지정해서 인터넷 통신을 `LISTEN` 상태로 실행

    ```bash
    sudo tcpdump -i en1 port 80 # 추가적으로 포트 80번으로 지정
    ```

2.  새로운 터미널을 열어서 임의로 80번 포트에 네트워크 통신을 진행

    ```bash
    echo "Hello World" | nc naver.com 80
    ```

    {: file="result"}

    ```bash
    HTTP/1.1 400 Bad request
    Content-length: 90
    Cache-Control: no-cache
    Connection: close
    Content-Type: text/html

    <html><body><h1>400 Bad request</h1>
    Your browser sent an invalid request.
    </body></html>
    ```

    {: .prompt-warning}

    > 존재하지 않는 서버로 당연히 통신 에러

3.  인터넷 통신을 `LISTEN` 상태로 유지하고 있는 터미널 확인

    {: file="result"}

    ```bash
    14:47:51.551763 IP 172.30.1.45.54147 > 223.130.200.219.http: Flags [S], seq 1493362503, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 3305467768 ecr 0,sackOK,eol], length 0
    14:47:51.564850 IP 223.130.200.219.http > 172.30.1.45.54147: Flags [S.], seq 1123520104, ack 1493362504, win 28960, options [mss 1440,sackOK,TS val 222617396 ecr 3305467768,nop,wscale 11], length 0
    14:47:51.565151 IP 172.30.1.45.54147 > 223.130.200.219.http: Flags [.], ack 1, win 2052, options [nop,nop,TS val 3305467782 ecr 222617396], length 0
    14:47:51.565245 IP 172.30.1.45.54147 > 223.130.200.219.http: Flags [P.], seq 1:13, ack 1, win 2052, options [nop,nop,TS val 3305467782 ecr 222617396], length 12: HTTP
    14:47:51.565267 IP 172.30.1.45.54147 > 223.130.200.219.http: Flags [F.], seq 13, ack 1, win 2052, options [nop,nop,TS val 3305467782 ecr 222617396], length 0
    14:47:51.578659 IP 223.130.200.219.http > 172.30.1.45.54147: Flags [P.], seq 1:208, ack 14, win 15, options [nop,nop,TS val 222617407 ecr 3305467782], length 207: HTTP: HTTP/1.1 400 Bad request
    14:47:51.578661 IP 223.130.200.219.http > 172.30.1.45.54147: Flags [F.], seq 208, ack 14, win 15, options [nop,nop,TS val 222617407 ecr 3305467782], length 0
    14:47:51.578941 IP 172.30.1.45.54147 > 223.130.200.219.http: Flags [.], ack 208, win 2049, options [nop,nop,TS val 3305467795 ecr 222617407], length 0
    14:47:51.579090 IP 172.30.1.45.54147 > 223.130.200.219.http: Flags [.], ack 209, win 2049, options [nop,nop,TS val 3305467795 ecr 222617407], length 0
    ```

- `172.30.1.45.54147`
  : 클라이언트 `IP`
- `223.130.200.219.http`
  : 서버 `IP` (`http` -> `80`)
- `172.30.1.45.54147 > 223.130.200.219.http`
  : "클라이언트가 서버에게" → "보내는 쪽 > 받는 쪽"
- `Flags  [S, S., ., P., F.]`
  : 앞서 설명한 플래그를 의미

  | Flag | 이름      |
  | ---- | --------- |
  | `S`  | `SYN`     |
  | `S.` | `SYN-ACK` |
  | `.`  | `ACK`     |
  | `P`  | `PSH`     |
  | `F`  | `FIN`     |

#### 3-Way Handshake 과정

![image_10][image_10]

1. 클라이언트(`172.30.1.45`) → 서버(`223.130.200.219`) : <ins>[SYN]</ins>, <ins>[S]</ins>
2. 서버(`223.130.200.219`) → 클라이언트(`172.30.1.45`) : <ins>[SYN-ACK]</ins>, <ins>[S.]</ins>
3. 클라이언트(`172.30.1.45`) → 서버(`223.130.200.219`) : <ins>[ACK]</ins>, <ins>[.]</ins>

{: .prompt-info}

> `seq` 번호는 순서 번호로써, 패킷의 전달 순서를 식별하는데 사용되는 값이다.
>
> 운영체제에 의해서 랜덤하게 생성되서 `SYN` 패킷에 담겨서 보내지며, 이를 받은 서버에는 동기화에 대한 답신으로 `seq` 번호를 +1 증가시키고 `ack`에 담아 응답한다.

#### 데이터 통신 과정

![image_11][image_11]

1. 클라이언트(`172.30.1.45`) → 서버(`223.130.200.219`) : <ins>[PSH-ACK]</ins>, <ins>[P.]</ins>
2. 클라이언트(`172.30.1.45`) → 서버(`223.130.200.219`) : <ins>[FIN-ACK]</ins>, <ins>[F.]</ins>
   - 예상해보자면, 서버 측에서 통신 오류로 인해 `PSH-ACK` 이후에 바로 `FIN-ACK`로 통신을 종료시킨 듯 하다. (더 알아보고 답을 찾을 예정)
3. 서버(`223.130.200.219`) → 클라이언트(`172.30.1.45`) : <ins>[PSH-ACK]</ins>, <ins>[P.]</ins>
   - 해당 로그의 정보로 `HTTP: HTTP/1.1 400 Bad request` 로그가 있는 것으로 봐서, 서버 측에서 에러를 클라이언트에게 `PSH-ACK`한 작업으로 보인다. (더 알아보고 답을 찾을 예정)
4. 서버(`223.130.200.219`) → 클라이언트(`172.30.1.45`) : <ins>[FIN-ACK]</ins>, <ins>[F.]</ins>

#### 4-Way Handshake 과정

![image_12][image_12]

최종적으로 위에서 설명한 것처럼 클라이언트와 서버 간의 통신은 이미 `FIN-ACK`를 통해 끊긴 상황이므로 추가적인 통신에 대한 플래그가 존재하지 않는다.

즉, 통신에 대한 플래그가 없기 때문에 `.`을 통한 Placeholder가 찍힌다. (추?측, 더 알아보고 답을 찾을 예정)

1. 클라이언트(`172.30.1.45`) → 서버(`223.130.200.219`) : <ins>[ACK]</ins>, <ins>[.]</ins>

### TCP의 전송 제어 기법

⚠️ 여기서부터는 추가적으로 작성 예정

## 참고 사이트

> [Inpa Dev - 🌐 아직도 모호한 TCP / UDP 개념 ❓ 쉽게 이해하자][ref_site_1]
>
> [Z.com Cloud - So sánh chi tiết TCP và UDP: Chọn giao thức nào tốt nhất?][ref_site_2]

<!-- 이미지 -->

[image_1]: {{page.image-path}}/tcp-udp_1.png
[image_2]: {{page.image-path}}/tcp-udp_2.png
[image_3]: {{page.image-path}}/tcp-udp_3.png
[image_4]: {{page.image-path}}/tcp-udp_4.png
[image_5]: {{page.image-path}}/tcp-udp_5.png
[image_6]: {{page.image-path}}/tcp-udp_6.png
[image_7]: {{page.image-path}}/tcp-udp_7.png
[image_8]: {{page.image-path}}/tcp-udp_8.png
[image_9]: {{page.image-path}}/tcp-udp_9.png
[image_10]: {{page.image-path}}/tcp-udp_10.png
[image_11]: {{page.image-path}}/tcp-udp_11.png
[image_12]: {{page.image-path}}/tcp-udp_12.png

<!-- 블로그 게시글 -->

[tcp-udp]: {{site.url}}/posts/tcp-udp

<!-- 참고 사이트 -->

[ref_site_1]: https://inpa.tistory.com/entry/NW-%F0%9F%8C%90-%EC%95%84%EC%A7%81%EB%8F%84-%EB%AA%A8%ED%98%B8%ED%95%9C-TCP-UDP-%EA%B0%9C%EB%85%90-%E2%9D%93-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90
[ref_site_2]: https://cloud.z.com/vn/news/udp/
