---
title: HTTP (4) - HTTP 캐싱
description: HTTP의 캐시 제어, 캐시 검증∙조건부 요청 등 HTTP의 캐시와 관련된 정리
categories: [Computer Science, Network]
tags: [computer-science, network, http, cache] # TAG names should always be lowercase
pin: false
math: true
mermaid: true
published: true
private: true # 커스텀해서 만든 것
image-path: /assets/img/computer-science/network/http/http-4 # 이미지 공통 경로 변수
image:
  path: /assets/img/computer-science/network/http/http-4/http-4_1.png
  lqip: data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=
  alt: 웹 브라우저의 캐시 원리
---

## 웹 브라우저의 캐시(Cache) 원리

![image_2][image_2]

컴퓨터 운영 체제에서의 캐시(Cache)는 주기억장치에서 자주 사용하는 프로그램과 데이터를 하드디스크로부터 가져오는데 시간이 많이 걸리기 때문에 캐시 저장소에 임시로 적재해두고 빠르게 접근하기 위한 기술이다.

캐시는 비단 컴퓨터 OS에만 국한된 기술이 아니다.

임시 저장소에 적재해놓고 빠르게 액세스함으로써 처리 성능을 높인다는 개념 자체는 어디에서나 적용이 가능하다.

이는 인터넷(Internet)에서도 적용된다.

![image_3][image_3]

웹 브라우저는 서버와 HTTP 프로토콜을 통해 리소스를 서버에게 요청을 하여 가져오고, 이를 사용자에게 리소스를 화면으로 보여주거나 제공한다.

이러한 통신 과정을 거치면서 클라이언트는 네트워크를 거치는 시간이 소비되며, 서버는 요청을 처리하는데 시간이 소비된다.

만약 클라이언트가 이전에 받은 데이터와 똑같은 데이터를 서버에 재요청을 할 때, 똑같은 통신 과정을 거치게된다면, 이 과정은 낭비라고 할 수 있다.

따라서 이러한 낭비를 줄이기 위한 해결책으로 캐시의 개념을 웹 브라우저에 그대로 적용한, HTTP에서 제공하는 헤더(Headers)인 `Cache-Control`이다.

브라우저는 이 `Cache-Control` 헤더를 적절하게 사용함으로써, 상황에 따라 서버의 부하를 줄일 수 있으며, 클라이언트는 네트워크 통신 기간이나 트래픽의 양을 줄일 수 있게 되었다.

하지만 캐시(Cache)는 다루기가 까다로운게, 캐싱을 잘못하면 불일치한 리소스를 받게 되거나 서비스 의도와는 다른 동작을 할 수 있게 되기 때문에 캐시를 다루는 기술을 확실하게 알아둘 필요는 있다.

## HTTP 캐시 제어

### 캐시 제어 헤더의 종류

#### Cache-Control 헤더

![image_4][image_4]

![image_5][image_5]

캐시의 유효 시간(생명 주기)을 명시하는 응답(Response) 헤더로, 헤더 값의 파라미터 종류로는 아래와 같다.

- `max-age`
  - 캐시 유효 시간을 의미하며, 초 단위
- `no-cache`
  - 데이터는 캐시해도 되지만, <ins>항상 Origin Server에 검증</ins> 후 사용
- `no-store`
  - 데이터에 민감한 정보가 포함되어 있어서 <ins>저장 불가</ins> 혹은 최대한 <ins>빠르게 삭제</ins>해야함
- `public`
  - `public` 캐시(프록시 캐시 서버)에 저장이 가능
- `private`
  - `public` 캐시에 저장 불가
- `s-maxage`
  - 프록시 캐시 서버에 적용되는 `max-age`
- `Age`
  - Origin Server의 응답이 프록시 캐시 서버에 머문 시간으로, 초 단위
- `must-revalidate`
  - 캐시 만료 후 최초 조회시, Origin Server에 검증

위와 같은 다양한 캐시를 아래의 예시처럼 `,`(콤마)로 여러 파라미터를 열거해서 사용이 가능하다.

- `max-age=86400`
  : 응답은 최대 1일(60초 $\times$ 60분 $\times$ 24시간) 동안 브라우저 및 중간 캐시가 캐싱할 수 있다.
- `private, max-age=600`  
  : 응답은 최대 10분(60초 $\times$ 10분) 동안 (중간 캐시가 아닌) 브라우저가 캐싱할 수 있다.
- `public, max-age=31536000`
  : 응답은 1년 동안 모든 캐시가 저장할 수 있다.

#### Pragma 헤더

```http
HTTP/1.1 200 OK
Pragma: no-cache
```

HTTP/1.0 하위 호환을 위해 사용하는 캐시 제어 헤더이며, Cache-Control과 동일한 역할을 수행하지만 권장되지 않는다.

#### Expires 헤더

```http
HTTP/1.1 200 OK
Expires: Wed, 21 Oct 2015 07:28:00 GMT
```

캐시의 만료일을 명시하는 헤더로, 정확한 날짜를 지정해야 한다.

Cache-Control 헤더에도 `max-age`로 유효 시간을 명시하는 것이 더 추천되기 때문에, 현재는 사용이 권장되지 않고 하위 호환을 위해 사용된다.

만일 `max-age`와 동시에 사용되면 Expires는 무시된다.

### 웹 브라우저의 캐시 기본 동작

#### 캐시가 없을 경우 <ins class="red">X</ins>

만일 캐시가 없을 경우에 똑같은 이미지를 요청한다면, 서버에서는 동일한 이미지를 매번 1.1M 용량의 데이터로 응답해야 한다.

용량이 작은 리소스라면 큰 문제가 되지는 않겠지만, 용량이 커질 수록 통신 비용이 늘어나게 되고 로딩 속도도 느려지는 문제가 생긴다.

![image_6][image_6]
_캐시가 없을 경우, 요청/응답 시나리오_

1. 클라이언트에서 `star.jpg`{: .filepath} 이미지를 요청한다.
2. 서버에서는 해당 이미지가 있으면 응답을 줘야하는데, 이미지의 HTTP 헤더 + 바디를 합쳐 대략 1.1M 정도 용량의 데이터로 응답한다.
3. 클라이언트에서는 해당 이미지를 응답받아 사용한다.
4. 클라이언트에서는 `star.jpg`{: .filepath} 이미지를 다시 한 번 더 요청한다.
5. 서버에서는 동일한 이미지를 다시 1.1M 정도 용량의 데이터로 응답한다.
6. 클라이언트에서는 해당 이미지를 응답받아 사용한다.
7. 동일한 이미지를 요청하는데 네트워크를 통해 같은 데이터를 또 다운받아야 한다.

#### 캐시를 이용한 요청 <ins class="blue">O</ins>

그렇다면 캐시를 웹 브라우저에 적용하면 얼마나 이점이 있는지를 시나리오를 통해 알아보도록 한다.

1. 클라이언트에서 `star.jpg`{: .filepath} 이미지를 요청한다.

2. 서버에서는 해당 이미지를 응답해준다.

   이때, HTTP 메시지에 `cache-control` 헤더를 넣어주어 캐시의 유효 시간을 설정한다.

   ![image_7][image_7]
   _그림에서는 60초로 설정해서 60초 동안 해당 캐시가 유효하다는 의미이다._

3. 서버로부터 응답을 받게 되면, 클라이언트에서는 `cache-control` 헤더를 이해하고 웹 브라우저 캐시에 응답 결과를 60초 동안 저장한다.

   ![image_8][image_8]

4. 클라이언트가 `star.jpg`{: .filepath} 이미지를 재차 요청한다.

   ![image_9][image_9]
   _이때, 서버에게 가는 것이 아닌 우선 캐시 저장소를 조회하게 된다._

5. 만일 캐시되어있고, 60초 이내에 요청한 상태라면, 캐시에서 자료를 가져오게 된다.

   ![image_10][image_10]{: width="40%" .left}

   해당 이미지에서 볼 수 있듯이, <ins>캐시</ins>를 시용하게 되면, 한 번 응답받았던 데이터는 브라우저의 캐시 저장소에 남아 일정 시간 내에 계속해서 참조할 수 있기 때문에 서버로부터 불필요한 네트워크 다운로드를 효과적으로 줄일 수 있다.

   사용자는 빠른 서비스를 경험할 수 있고, 서버는 네트워크 사용량을 줄여 비용을 아낄 수 있게 된다.

   ![image_11_dark][image_11_dark]{: .dark .w-75 } ![image_12_dark][image_12_dark]{: .dark .w-75 }
   ![image_11_light][image_11_light]{: .light .w-75 } ![image_12_light][image_12_light]{: .light .w-75 }

#### 캐시 유효 시간이 지날 경우 <ins class="red">△</ins>

그렇다면 만약에 60초가 지나게 되어 캐시 유효 기간이 만료된 후에 클라이언트가 그 자료를 요청할 경우 어떻게 작동하는지 다음 시나리오를 통해 확인해보도록 한다.

> 앞의 과정은 위의 [캐시를 이용한 요청](#캐시를-이용한-요청-o)과 동일하기에 생략

1. 클라이언트가 `star.jpg`{: .filepath} 이미지를 재차 요청하지만, 60초의 캐시 유효 시간이 지나서 더 이상 가져올 수 없게 되었다.

   ![image_13][image_13]

2. 그러면 클라이언트는 다시 서버에게 처음과 같이 요청한다.

   ![image_14][image_14]
   _다시 네트워크 다운로드가 발생한다._

3. 서버는 똑같이 `cache-control` 헤더를 응답하고, 브라우저는 다시 자료를 캐시에 저장한다.

   ![image_15][image_15]

위의 시나리오에서 볼 수 있듯이, 캐시 유효 기간이 지났을 경우 처음과 같이 서버에 요청을 보내야 한다.

그러면 캐시 유효 기간을 길게 늘리면 되지 않을까하는 생각이 들 수 있다.

하지만 이는 좋은 방법이 아니다.

왜냐하면, 오랜 기간 변경되지 않아도 무방한 데이터가 있는 반면, 짧은 변경 주기를 갖는 데이터도 존재하기 때문이다.

만료 기간이 길 경우, 캐시 데이터 또한 오래된 데이터일 가능성이 높다는 것이다.

따라서, 비록 <ins class="red">캐시 유효 기간이 지났더라도, 오랜 기간 변경되지 않아도 되는 데이터</ins>일 경우에는 처음부터 요청을 하는 것이 낭비이다.

그래서 더욱 더 효율적인 캐시 전략을 위해 웹 브라우저에는 별도의 <ins>캐시 검증 로직</ins>을 수행하게 된다.

> "캐시를 얼마나 오래 유지해야 하는가?"에 대한 답은 없다고 봐야한다.
>
> 정해진 답이 있다기 보다는, 데이터의 성격과 데이터 사용에 대한 상황 등 복합적으로 생각해서 설정해야 한다.

## HTTP 캐시 검증 & 조건부 요청

### 캐시 검증의 헤더 종류

서버가 클라이언트에게 응답(Response)할 때 HTTP 메시지 헤더에 넣는 캐시 헤더 정보들이다.

#### Last-Modified 헤더

```http
HTTP/1.1 200 OK
Last-Modified: Mon, 19 Aug 2024 06:46:38 GMT
```

<ins>데이터의 최종 수정 시각</ins>을 명시하며, `If-Modified-Since` 요청(Request) 헤더와 함께 사용된다.

> 윈도우 파일을 예시로 들면, 최종 수정 시간과 같은 개념이다.

클라이언트가 캐시 유효 기간이 초과된 데이터를 서버에 요청하는 경우, 이를 기준으로 데이터가 수정되었는지를 검증한다.

> 예를 들어, 서버의 데이터 최종 수정 시각이 <ins class="blue">`Last-Modified`보다 이후라면 데이터가 수정된 것</ins>으로 간주하고, 서버의 데이터 최종 수정 시각이 <ins class="red">`Last-Modified`와 같다면 데이터가 수정되지 않은 것</ins>으로 간주한다.

#### ETag 헤더

```http
HTTP/1.1 200 OK
Etag: W/"be2-8DMK/T1o7uae6ugR1qz+KkMIu94"
```

<ins>특정 버전의 리소스를 식별하는 고유 식별자</ins>(데이터의 버전 이름 혹은 해시 값)이다.

서버는 파일이 변경될 때마다 새로운 ETag 값을 생성하고, 이전 ETag 값을 유지하며, `If-None-Match` 요청(Request) 헤더와 함께 사용된다.

위에서 설명한 `Last-Modified` 헤더의 한계를 극복하기 위해 만들어진 리소스 검증 헤더이다.

### 조건부 요청 헤더의 종류

클라이언트가 서버에 요청(Request)할 때 HTTP 메시지 헤더에 넣는 캐시 관련 헤더 정보들이다.

#### If-Modified-Since 헤더

```http
GET https://jsonplaceholder.typicode.com/comments?postId=1 HTTP/1.1
If-Modified-Since: Mon, 19 Aug 2024 07:12:55 GMT
```

클라이언트의 요청(Request)시 사용되며, 캐시 데이터의 `Last-Modified` 값이 들어간다.

서버의 데이터 최종 수정 시각과 캐시 데이터의 최종 수정 시각을 비교하여 데이터 수정 여부를 확인하기 위해 사용한다.

- 캐시에 있는 리소스 수정 시각과 서버에 있는 리소스 수정 시작이 <ins class="red">같으면, 304 Not Modified</ins> 응답

  → 캐시 재사용

- 캐시에 있는 리소스 수정 시각과 서버에 있는 리소스 수정 시작이 <ins class="blue">다르면, 200 OK</ins> 응답

  → 새로운 데이터 전송 (네트워크를 통한 다운로드)

#### If-None-Match 헤더

```http
GET https://jsonplaceholder.typicode.com/comments?postId=1 HTTP/1.1
If-None-Match: W/"be2-8DMK/T1o7uae6ugR1qz+KkMIu94"
```

클라이언트의 요청(Request)시 사용되며, 캐시 데이터의 `Etag` 값이 들어간다.

서버의 데이터 `ETag`와 캐시 데이터의 `ETag`를 비교해서 데이터 수정 여부를 확인하기 위해 사용한다.

- 캐시에 있는 `ETag`와 서버에 있는 `ETag`가 <ins class="red">같으면, 304 Not Modified</ins> 응답

  → 캐시 재사용

- 캐시에 있는 `ETag`와 서버에 있는 `ETag`가 <ins class="blue">다르면, 200 OK</ins> 응답

  → 새로운 데이터 전송 (네트워크를 통한 다운로드)

#### If-Unmodified-Since / If-Match 헤더

```http
GET https://jsonplaceholder.typicode.com/comments?postId=1 HTTP/1.1
If-Unmodified-Since: Mon, 19 Aug 2024 07:12:55 GMT
```

```http
GET https://jsonplaceholder.typicode.com/comments?postId=1 HTTP/1.1
If-None-Match: W/"be2-8DMK/T1o7uae6ugR1qz+KkMIu94"
```

각각 `If-Unmodified-Since`와 `If-None-Match` 헤더의 반대 역할을 수행한다고 보면 된다.

이 헤더들은 <ins>412 Precondition Failed 상태 코드를 반환</ins>하는데 사용된다.

{: .prompt-info}

> 412 Precondition Failed
>
> 대상 리소스에 대한 액세스가 거부되었음을 나타내며, 이는 `If-Unmodified-Since` 또는 `If-None-Match` 헤더에 정의된 조건이 충족되지 않을 때 GET 또는 HEAD 이외의 메서드에 대한 조건부 요청에서 발생한다.

### 웹 브라우저의 조건부 요청 & 검증 동작

캐시 만료 후에도 서버에서 해당 리소스를 수정하거나 업데이트하지 않은 경우라면, 서버에서 동일한 데이터를 요청해서 응답받는 것은 여러모로 비용 낭비이다.

이럴 떄는 이미 저장된 캐시를 재사용할 수만 있다면 리소스 낭비를 줄일 수 있을 것이다.

이러한 전략을 이용하기 위해서는 <ins>어떻게 클라이언트의 데이터와 서버의 데이터가 동일하다는 것을 알 수 있는지</ins>에 대해서 알아야 한다.

그래서 HTTP에서는 추가적인 검증 헤더를 이용하여 처리한다.

#### 문서 수정 시간 방식 (Last-Modified & If-Modified-Since)

가장 간단한 방법은 리소스 수정 시각을 이용해서 리소스 변경 사항을 확인하는 것이다.

예를 들어, 캐시에 저장된 리소스의 수정 시각과 서버에 저장된 리소스의 수정 시각이 같으면 변경 사항이 없기 때문에 캐시에 있는 것을 재활용하면 되고, 수정 시각이 다르면 최신 리소스를 갱신해야 하기 때문에 새로 서버에서 보내주는 것이다.

![image_16][image_16]{: width="75%"}

1. 클라이언트에서 `star.jpg`{: .filepath} 이미지를 요청한다.
2. 서버는 `cache-control` 헤더를 이용하여 캐시 유효 기간을 60초로 설정하고, 추가적으로 `Last-Modified` 헤더를 통해 <ins>마지막으로 리소스가 수정된 시간</ins> 정보를 넣어 응답해준다.

   ![image_17][image_17]

3. 클라이언트는 캐시에 응답 결과를 저장할 때, 데이터 최종 수정일도 함께 저장한다.

   ![image_18][image_18]{: width="50%"}

4. 100초가 지난 후 캐시 유효 시간이 초과된 상태에서 클라이언트에서 `star.jpg`{: .filepath} 이미지를 재차 요청한다.

   ![image_19][image_19]

5. 이때, 캐시에 최종 수정일 정보(`Last-Modified`) 값이 들어있다면, 클라이언트는 요청 메시지 헤더에 `If-Modified-Since` 값을 담아서 서버에 보낸다.

   ![image_20][image_20]

6. 서버에서 만일 클라이언트가 요청한 헤더의 자료 최종 수정일과 서버에 있는 자료의 수정일을 비교해서 데이터가 수정되지 않았을 경우, 304 Not Modified로 응답한다.

   ![image_21][image_21]
   _이때, 리소스를 담지 않고 전송하기 때문에 전송 데이터가 없으며, 0.1M만 전송한다._

7. 304 Not Modified 응답을 받은 클라이언트는 리소스의 상태가 수정이 없는 최신 상태임을 인지하게 되고, 안전하게 캐시에서 다시 리소스를 가져오고 다시 캐시 유효 기간을 갱신한다.

   ![image_22][image_22]{: width="70%"}

정리하자면, 원래대로면 1.1M 응답 데이터를 받아오게 되어있지만, 조건부 요청을 통해 비록 캐시 유효 기간이 지났더라도 리소스가 변경이 없다면, 캐시에서 재활용해도 된다는 취지로, 서버는 그냥 헤더 메시지만 응답하게 되니 1M를 절약하게 된 것이다.

결과적으로 네트워크 다운로드는 발생하지만, 0.1M만 받게 되면서 사용자는 빠르게 서비스를 이용할 수 있게 된다.

아래의 경우, 개발자 도구에서 네트워크 응답 화면을 통해 확인하는 방법이다.

<!-- ![image_23_dark][image_23_dark]{: .dark .w-75}
![image_23_light][image_23_light]{: .light .w-75} -->

![image_23][image_23]

`Cache-Control` 헤더의 `max-age` 값을 5초로 지정하고 계속 동일한 요청을 할 경우, 초가 지나면서 캐시 유효 기간이 만료되어 다시 서버에 요청을 하지만, <ins>원본 용량(994KB)보다 훨씬 적은 192B를 받는 걸 볼 수 있다.</ins>

즉, 이미지는 받지 않고 HTTP 메시지만 받으며, 캐시 저장소에서 리소스를 다시 가져오는 동작을 5초마다 하고 있다는 것이다.

#### Last-Modified & If-Modified-Since 방식의 한계

하지만 단순히 리소스의 수정 시각으로 캐시 이용 전략을 세우는 것에는 다음과 같은 한계점이 존재한다.

- 1초 미만(0.X초)의 단위로 캐시 조정이 불가능하다.
- 날짜 기반의 로직을 사용하기 때문에 한계가 있다.
  > 예를 들어, `test.txt`{: .filepath} 파일의 내용을 `A` → `B`로 수정했지만, 다시 `B` → `A`로 롤백하는 경우, 내용은 캐시에 있는 것과 같지만, 날짜가 변경되서 다시 받아야 하는 경우가 있다.
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우에 한계가 있다.
  > 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지해야 하는 경우

#### ETag 비교 방식 (ETag & If-None-Match)

위와 같이 Last-Modified & If-Modified-Since 방식의 한계로 인해, 서버에서 완전히 캐시를 컨트롤하고 싶다면 `ETag`를 사용하여 <ins>임의의 해시 값</ins>을 활용해서 컨텐츠를 좀 더 면밀하게 관리할 수 있다.

만약에 데이터가 변경되면 `ETag`가 변경되기 때문에, 단순히 `ETag`가 같다면 데이터가 수정되지 않은 것이고, `ETag`가 다르면 데이터가 수정된 것으로 간주하게 된다.

![image_24][image_24]{: width="75%"}

1. 클라이언트에서 `star.jpg`{: .filepath} 이미지를 요청한다.
2. 서버는 헤더에 `ETag`를 작성해서 이미지와 함께 응답해준다.

   ![image_25][image_25]

3. 클라이언트는 `ETag` 값을 캐시에 저장한다.

   ![image_26][image_26]{: width="50%"}

4. 100초가 지난 후 캐시 유효 시간이 초과된 상태에서 클라이언트에서 `star.jpg`{: .filepath} 이미지를 재차 요청한다.

   ![image_27][image_27]

5. 이때, 캐시에 `ETag` 값이 들어있다면, 클라이언트는 요청 메시지 헤더에 `If-None-Match` 값을 담아서 서버에 보낸다.

   ![image_28][image_28]

6. 서버에서 데이터가 변경되지 않았을 경우, `ETag`는 동일할 것이며, 그러므로 인해서 `If-None-Match` 로직은 실패 처리가 되어, 304 Not Modified로 응답한다.

   ![image_29][image_29]
   _이때, 리소스를 담지 않고 전송하기 때문에 전송 데이터가 없으며, 0.1M만 전송한다._

7. 304 Not Modified 응답을 받은 클라이언트는 리소스 수정이 없으므로 최신 상태임을 인지하게 되고, 안전하게 캐시에서 다시 리소스를 가져오고, 다시 캐시 유효 기간을 갱신한다.

   ![image_30][image_30]

정리하면, `ETag`만 서버에 보내서, 값이 동일하다면 리소스를 유지하고 값이 다르면 리소스를 다시 받아온다.

즉, 캐시 제어 로직을 파일 수정 시각으로 비교하는 것이 아닌, 서버에서 관리를 하는 것이다.

예를 들어, 서버는 베타 오픈 기간 3일간 파일이 변경되어도 `ETag`를 동일하게 유지하고 있다가, 애플리케이션 배포 주기에 맞춰서 `ETag`를 모두 갱신하는 식응로 자체 관리함으로써, 클라이언트는 단순하게 이 값을 서버에 제공만 하면 되고, 별도로 캐시 매커니즘을 알 필요가 없게 되는 것이다.

## 프록시(Proxy) 캐시

⚠️ 추가적으로 작성 예정

## 참고 사이트

> [Inpa Dev - 🌐 웹 브라우저의 Cache 전략 & 헤더 다루기][ref_site_1]
>
> [Semantics - HTTP (7) - 캐시와 조건부 요청 (Last-Modified / ETag)][ref_site_2]

<!-- 이미지 -->

[image_1]: {{page.image-path}}/http-4_1.png
[image_2]: {{page.image-path}}/http-4_2.png
[image_3]: {{page.image-path}}/http-4_3.png
[image_4]: {{page.image-path}}/http-4_4.png
[image_5]: {{page.image-path}}/http-4_5.png
[image_6]: {{page.image-path}}/http-4_6.png
[image_7]: {{page.image-path}}/http-4_7.png
[image_8]: {{page.image-path}}/http-4_8.png
[image_9]: {{page.image-path}}/http-4_9.png
[image_10]: {{page.image-path}}/http-4_10.png
[image_11_dark]: {{page.image-path}}/http-4_11_dark.png
[image_12_dark]: {{page.image-path}}/http-4_12_dark.png
[image_11_light]: {{page.image-path}}/http-4_11_light.png
[image_12_light]: {{page.image-path}}/http-4_12_light.png
[image_13]: {{page.image-path}}/http-4_13.png
[image_14]: {{page.image-path}}/http-4_14.png
[image_15]: {{page.image-path}}/http-4_15.png
[image_16]: {{page.image-path}}/http-4_16.png
[image_17]: {{page.image-path}}/http-4_17.png
[image_18]: {{page.image-path}}/http-4_18.png
[image_19]: {{page.image-path}}/http-4_19.png
[image_20]: {{page.image-path}}/http-4_20.png
[image_21]: {{page.image-path}}/http-4_21.png
[image_22]: {{page.image-path}}/http-4_22.png
[image_23]: {{page.image-path}}/http-4_23.png
[image_23_dark]: {{page.image-path}}/http-4_23_dark.png
[image_23_light]: {{page.image-path}}/http-4_23_light.png
[image_24]: {{page.image-path}}/http-4_24.png
[image_25]: {{page.image-path}}/http-4_25.png
[image_26]: {{page.image-path}}/http-4_26.png
[image_27]: {{page.image-path}}/http-4_27.png
[image_28]: {{page.image-path}}/http-4_28.png
[image_29]: {{page.image-path}}/http-4_29.png
[image_30]: {{page.image-path}}/http-4_30.png
[image_31]: {{page.image-path}}/http-4_31.png
[image_32]: {{page.image-path}}/http-4_32.png
[image_33]: {{page.image-path}}/http-4_33.png
[image_34]: {{page.image-path}}/http-4_34.png
[image_35]: {{page.image-path}}/http-4_35.png
[image_36]: {{page.image-path}}/http-4_36.png
[image_37]: {{page.image-path}}/http-4_37.png
[image_38]: {{page.image-path}}/http-4_38.png
[image_39]: {{page.image-path}}/http-4_39.png

<!-- 블로그 게시글 -->

[http-2]: {{site.url}}/posts/http-2

<!-- 참고 사이트 -->

[ref_site_1]: https://inpa.tistory.com/entry/HTTP-%F0%9F%8C%90-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%BA%90%EC%8B%9C-%EC%A0%84%EB%9E%B5-Cache-Headers-%EB%8B%A4%EB%A3%A8%EA%B8%B0
[ref_site_2]: https://velog.io/@neity16/HTTP-7-%EC%BA%90%EC%8B%9C%EC%99%80-%EC%A1%B0%EA%B1%B4%EB%B6%80-%EC%9A%94%EC%B2%AD-Last-Modified-ETag
