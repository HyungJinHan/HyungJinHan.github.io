---
title: ArrayList (2) - ArrayList 구현 (Java)
description: Java의 자료 구조 중 하나인 ArrayList의 이해를 위한 메서드 구현
categories: [Computer Science, Data Structure]
tags: [computer-science, data-structure, arraylist] # TAG names should always be lowercase
pin: false
math: true
mermaid: true
published: true
private: true # 커스텀해서 만든 것
image-path: /assets/img/computer-science/data-structure/arraylist/arraylist-2 # 이미지 공통 경로 변수
image:
  path: /assets/img/computer-science/data-structure/arraylist/arraylist_1.png
  lqip: data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=
  alt: Java's ArrayList
---

## ArrayList 자료 구조

ArrayList 특징으로는 아래와 같이 요약할 수 있다.

- <ins>연속적인 데이터의 리스트</ins>이다.
  - 데이터는 연속적으로 적재되어야 하며, 중간에 빈 공간이 존재해서는 안된다.
- ArrayList 클래스는 내부적으로 `Object[]` 배열을 이용하여 요소를 저장한다.
- 배열을 이용하기 때문에 <ins class="blue">인덱스를 이용해 요소에 빠르게 접근</ins>할 수 있다.
- 크기가 고정되어있는 배열과 달리, 데이터 적재량에 따라 <ins class="blue">가변적으로 공간을 늘리거나 줄인다.</ins>
- 그러나 배열 공간이 꽉 찰때 마다 <ins class="red">배열을 Copy하는 방식으로 늘리므로, 이 과정에서 지연이 발생</ins>하게 된다.
- 데이터를 리스트 중간에 삽입/삭제할 경우, 중간에 빈 공간이 생기지 안도록 <ins class="red">요소들의 위치를 앞뒤로 알아서 이동</ins>시키기 때문에 <ins class="red">삽입/삭제 동작이 느리다.</ins>
  - 따라서 조희를 많이 하는 경우에 사용하는 것이 좋다.

> LinkedList에 대한 추가적인 설명에 대해서는 [#ArrayList (1) - ArrayList 구조][post-arraylist] 게시글을 참고

## ArrayList 구현 (기본)

`java.util` 패키지의 ArrayList를 보면 메소드가 굉장히 많다.

따라서 해당 게시글에서는 이를 모두 구현한다기 보다는 ArrayList 자료형의 특징을 알 수 있는 메소드만 구현하여 ArrayList가 코드 내부에서 어떻게 동작하는지를 위주로 구현할 예정이다.

### List 인터페이스 정의

실제로 ArrayList 클래스는 List 인터페이스를 `implements`하여 구현하기 때문에 이와 비슷하게 인터페이스를 구현하고 추상 메서드를 재정의할 예정이다.

먼저 실제 List 인터페이스에 정의되어 있는 추상 메서드들 중에서 핵심적인 부분만 가져와 `MyList` 인터페이스로 제네릭을 이용해 정의했다.

이 MyList 인터페이스를 `implements`해서 `MyArrayList`를 만들어 볼 것이다.

```java
public interface MyList<T> {
  boolean add(T value); // 요소를 추가
  void add(int index, T value); // 요소를 특정 위치에 추가

  boolean remove(Object value); // 요소를 삭제
  T remove(int index); // 특정 위치에 있는 요소를 삭제

  T get(int index); // 요소 가져오기
  void set(int index, T value); // 특정 위치에 있는 요소를 새 요소로 대체

  boolean contains(Object value); // 특정 요소가 리스트에 있는지 여부를 확인
  int indexOf(Object value); // 특정 요소가 몇 번째 위치에 있는지를 반환 (순차 검색)
  int lastIndexOf(Object o); // 특정 요소가 몇 번째 위치에 있는지를 반환 (역순 검색)

  int size(); // 요소의 개수를 반환
  boolean isEmpty(); // 요소가 비어있는지 확인

  public void clear(); // 요소를 모두 삭제
}
```

```java
public class MyArrayList<E> implements MyList<E> {
  // ...
}
```

### 클래스 필드 정의하기

```java
public class MyArrayList<E> implements MyList<E> {
  private static final int DEFAULT_CAPACITY = 5; // 생성자로 배여링 생성될 때 기본 용량
  private static final Object[] EMPTY_ELEMENTDATA = {};

  private int size; // elementData 배열의 총 개수(크기)를 나타내는 변수
  Object[] elementData; // 자료를 담을 배열

  // ...
}
```

- `DEFAULT_CAPACITY`
  : - 배열이 생성될 때의 디폴트 할당 용량
- `EMPTY_ELEMENTDATA`
  : - 아무것도 없는 빈 배열
- `elementData`
  : - 실제 `MyArrayList`에 들어오는 데이터들을 담는 배열 자료
- `size`
  : - `elementData` 배열에 담긴 요소의 총 개수 (배열 크기)

ArrayList 클래스에 데이터들을 저장하기 위해 내부에 Object 배열이 구현되어 있다.

이 내부 배열을 가지고 메서드로 조작하여 리스트 자료를 이용하는 것이다.

그런데 여기서 가장 중요한 멤버가 `size` 변수이다.

`size`는 배열의 크기를 나타내는 변수인데, 어차피 `elementData.length`로 배열의 크기를 얻을 수 있는데 굳이 변수로 분리한 이유는 자료를 담은 배열 `elementData`의 크기가 `MyArrayList` 클래스의 크기를 대변해주지 못하기 때문이다.

예를 들어 데이터를 `add` 한다고 하면, 배열이 꽉 차있는지 비어있는지를 확인하고 추가해야 하는데, 이러한 검사를 `size` 변수 값의 비교를 통해 처리하기 때문이다.

또한 적재할 인덱스 위치 값으로도 쓰여진다.

#### ⚠️ Capacity와 Size

리스트의 Capacity와 Size의 차이를 혼동해서는 안된다.

![image_1_dark][image_1_dark]{: .dark }
![image_1_light][image_1_light]{: .light }

Capacity는 배열의 전체 공간의 용량을 말하는 것이고, Size는 배열의 모든 요소의 개수(크기)를 뜻하는 개념이다.

### 생성자 구현하기

Java의 ArrayList 사용법을 보면 인스턴스화할 때, 파라미터를 주기도 하고 주지 않기도 한다.

파라미터를 줄 경우, 미리 지정한 수만큼 공간(Capacity)을 할당하는데, 이를 구현하기 위해 생성자를 Overloading 처리한다.

또한 사용자가 파라미터에 옳지 않은 값을 줄 수도 있기 때문에, 이를 잘 캐치하여 분기 처리해야 한다.

```java
MyArrayList<Object> list1 = new MyArrayList<>();

MyArrayList<Object> list2 = new MyArrayList<>(50);

MyArrayList<Object> list3 = new MyArrayList<>(0);

MyArrayList<Object> list4 = new MyArrayList<>(-50);
```

```java
// ...

// 생성자 (초기 공간 할당 X)
public MyArrayList() {
  this.elementData = new Object[DEFAULT_CAPACITY];
  this.size = 0;
}

// 생성자 (초기 공간 할당 X)
public MyArrayList(int capacity) {
  // 파라미터의 값이 양수일 경우, 그대로 용량으로 배열을 생성
  if (capacity > 0) {
    this.elementData = new Object[capacity];
  }

  // 파라미터의 값이 0일 경우, 인자를 주지 않고 인스턴스화한 것과 같음
  // 디폴트 용량으로 초기화
  else if (capacity == 0) {
    this.elementData = new Object[DEFAULT_CAPACITY];
  }

  // 파라미터의 값을 음수로 설정할 경우, 예외를 발생시키도록 안전하게 설계
  else if (capacity < 0) {
    throw new RuntimeException(new IllegalAccessException("리스트 용량 설정이 잘못되었습니다."));
  }

  this.size = 0;
}
```

### resize 구현하기

리스트와 배열의 가장 큰 차이점은 리스트는 동적으로 크기를 늘렸다 줄였다 할 수 있는 것이다. (가변 배열)

만약에 용량(Capacity)가 꽉 차서 빈 공간이 없는데 새로운 데이터가 들어오면 배열의 용량을 늘릴 필요가 있다.

반대로 데이터를 삭제해서 들어있는 데이터 개수에 비해 용량이 너무 크다면 배열의 용량을 줄여서 메모리적으로 최적화를 노릴 수도 있다.

`resize()` 메서드는 리스트에 요소가 추가/삭제 등의 동작이 될 떄 기본적으로 호출된다.

그리고 배열의 크기(Size)와 배열의 용량(Capacity)을 비교해서, 크거나 작은 경우 이를 감지해서 리사이징을 처리하여 메모리 최적화를 노린다고 보면 된다.

아래와 같이 배열에 데이터가 추가/삭제될 때마다 실행되는 `resize()` 내부용 메서드를 구현하고, `size`와 `capacity`를 비교하는 총 3가지의 분기를 구현해준다.

```java
// ...

// 클래스 내부에서만 실행되는 메소드이기 때문에 private
private void resize() {
  // 현재 배열의 크기를 얻음
  int element_capacity = elementData.length;

  if("용량이 꽉 찬 경우"){ ... }

  if("용량에 비해 데이터 양이 적은 경우"){ ... }

  if("들어있는 데이터가 하나도 없을 경우 (빈 배열)"){ ... }
}
```

#### 1. 용량이 꽉 찬 경우

아래 코드에서 용량의 2배로 설정하는 이유는 공간을 넉넉하게 유지하기 위함이다.

왜냐하면 `resize` 메서드가 자주 호출되어서 배열을 복사하고, 새로 만들고 하는 행위가 빈번하게 일어난다면, 성능 저하가 올 수 있기 때문이다.

빈 공간은 자동으로 `null`로 채워지기 때문에 문제될 것 없다.

{: .prompt-warning}

> 다만, 자료 구조 알고리즘에 따라 확장 기준이 다를 수 있다.

```java
import java.util.Arrays;

// ...

private void resize() {
  // 현재 배열의 크기를 얻음
  int element_capacity = elementData.length;

  // 용량이 꽉 찬 경우
  if(element_capacity == size) {
    int new_capacity = element_capacity * 2;
    // 현재 용량의 2배로 넉넉하게 공간을 유지

    elementData = Arrays.copyOf(elementData, new_capacity);
    // 복사할 배열을 new_capacity 용량만큼 설정
    // elementData 원소들을 전체 복사해서 넣고 반환
    // 빈 공간은 null

    return;
  }

  if("용량에 비해 데이터 양이 적은 경우"){ ... }

  if("들어있는 데이터가 하나도 없을 경우 (빈 배열)"){ ... }
}
```

#### 2. 용량에 비해 데이터 양이 적은 경우

적정한 공간을 유지하다 너뭅 배열 원소가 공간에 비해 적게 들어있을 경우, 최적화를 위해 리사이징하는 작업이다.

## ArrayList 구현 (심화)

## 참고 사이트

> [Inpa Dev - 🛠️ ArrayList 자료구조 실전 구현 강의 (JAVA)][ref_site_1]

<!-- 이미지 -->

[image_1_dark]: {{page.image-path}}/arraylist_1_dark.png
[image_1_light]: {{page.image-path}}/arraylist_1_light.png
[image_2]: {{page.image-path}}/arraylist_2.png
[image_3]: {{page.image-path}}/arraylist_3.png
[image_4]: {{page.image-path}}/arraylist_4.png
[image_5]: {{page.image-path}}/arraylist_5.png
[image_6]: {{page.image-path}}/arraylist_6.png

<!-- 블로그 게시글 -->

[post-arraylist]: {{site.url}}/posts/arraylist-1

<!-- 참고 사이트 -->

[ref_site_1]: https://inpa.tistory.com/entry/DS-%F0%9F%A7%B1-ArrayList-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EC%A7%81%EC%A0%91-%EA%B5%AC%ED%98%84-%EA%B0%95%EC%9D%98#arraylist_%EC%8B%A4%EC%A0%84_%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0_%EA%B8%B0%EB%B3%B8%ED%8E%B8
