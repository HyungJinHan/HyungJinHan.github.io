---
title: 정보처리기사 실기 SQL 정리
description: 정보처리기사 실기 SQL 기출 문제 정리 (feat 시나공)
categories:
  - Computer Science
  - 정보처리기사
tags:
  - 정보처리기사
pin: false
math: true
mermaid: true
published: true
done: false
image-path: /assets/img/notion-post/정보처리기사-실기-SQL-정리
image:
  path: /assets/img/notion-post/정보처리기사-실기-SQL-정리/q-net.png
  lqip: data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=
  alt: 정보처리기사 실기 SQL 정리
date: '2025-11-24 07:48:00'
---



## SQL 기출 문제 정리


---



### SQL 명령문의 기본 형식과 조건

1. 다음과 같이 테이블을 정의하고 튜플을 삽입하였을 때 각 번호(①, ②)의 SQL문을 실행한 결과를 쓰시오.

	```sql
	CREATE TABLE '부서' (
		'부서코드' INT PRIMARY KEY,
		'부서명' VARCHAR(20)
	);
	
	CREATE TABLE '직원' (
		'직원코드' INT PRIMARY KEY,
		'부서코드' INT,
		'직원명' VARCHAR(20),
		FOREIGN KEY('부서코드') REFERENCES '부서'('부서코드')
			ON DELETE CASCADE
	);
	
	INSERT INTO '부서' VALUES(10, '영업부');
	INSERT INTO '부서' VALUES(20, '기획부');
	INSERT INTO '부서' VALUES(30, '개발부');
	
	INSERT INTO '직원' VALUES(1001, 10, '이진수');
	INSERT INTO '직원' VALUES(1002, 10, '곽연경');
	INSERT INTO '직원' VALUES(1003, 20, '김선길');
	INSERT INTO '직원' VALUES(1004, 20, '최민수');
	INSERT INTO '직원' VALUES(1005, 20, '이용갑');
	INSERT INTO '직원' VALUES(1006, 30, '박종일');
	INSERT INTO '직원' VALUES(1007, 30, '박미경');
	```



	①


	```sql
	SELECT DISTINCT COUNT('부서코드') FROM '직원' WHERE '부서코드' = 20;
	```



	②


	```sql
	DELETE FROM '부서' WHERE '부서코드' = 20;
	SELECT DISTINCT COUNT('부서코드') FROM '직원';
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① - 3


	② - 4


	\[ 해설 \]


	```sql
	CREATE TABLE '부서' (
	-- <부서 테이블을 생성한다.>
		'부서코드' INT PRIMARY KEY,
		-- '부서코드' 속성은 정수형이며, 기본키로 정의한다.
		'부서명' VARCHAR(20)
		-- '부서명' 속성은 가변길이 문자 20자이다.
	);
	
	CREATE TABLE '직원' (
	-- <직원> 테이블을 생성한다.
		'직원코드' INT PRIMARY KEY,
		-- '직원코드' 속성은 정수형이며, 기본키로 정의한다.
		'부서코드' INT,
		-- '부서코드' 속성은 정수형이다.
		'직원명' VARCHAR(20),
		-- '직원명' 속성은 가변길이 문자 20이다.
		FOREIGN KEY('부서코드') REFERENCES '부서'('부서코드')
		-- '부서코드' 속성은 <부서> 테이블의 '부서코드' 속성을 참조하는 외래키이다.
			ON DELETE CASCADE
			-- <부서> 테이블에서 튜플이 삭제되면 관련된 모든 튜플이 함께 삭제된다.
	);
	
	INSERT INTO '부서' VALUES(10, '영업부'); -- 1
	INSERT INTO '부서' VALUES(20, '기획부'); -- 2
	INSERT INTO '부서' VALUES(30, '개발부'); -- 3
	
	INSERT INTO '직원' VALUES(1001, 10, '이진수'); -- 4
	INSERT INTO '직원' VALUES(1002, 10, '곽연경'); -- 5
	INSERT INTO '직원' VALUES(1003, 20, '김선길'); -- 6
	INSERT INTO '직원' VALUES(1004, 20, '최민수'); -- 7
	INSERT INTO '직원' VALUES(1005, 20, '이용갑'); -- 8
	INSERT INTO '직원' VALUES(1006, 30, '박종일'); -- 9
	INSERT INTO '직원' VALUES(1007, 30, '박미경'); -- 10
	```


	- 1 ~ 3번 SQL문이 수행된 후 \<부서\> 테이블은 다음과 같다.

		\<부서\>


		| 부서코드  | 부서명  |
		| :---: | :---: |
		| 10             | 영업부           |
		| 20             | 기획부           |
		| 30             | 개발부           |

	- 4 ~ 10번 SQL문이 수행된 후 \<직원\> 테이블은 다음과 같다.

		\<직원\>


		| 직원코드  | 부서코드  | 직원명  |
		| :---: | :---: | :---: |
		| 1001           | 10             | 이진수           |
		| 1002           | 10             | 곽연경           |
		| 1003           | 20             | 김선길           |
		| 1004           | 20             | 최민수           |
		| 1005           | 20             | 이용갑           |
		| 1006           | 30             | 박종일           |
		| 1007           | 30             | 박미경           |


	\[ ① SQL 문 해설 \]


	```sql
	SELECT DISTINCT COUNT('부서코드')
	-- '부서코드'의 개수를 표시하되, 표시된 개수 중 중복된 값은 한 번만 표시한다.
	FROM '직원'
	-- <직원> 테이블에서 검색한다.
	WHERE '부서코드' = 20;
	-- '부서코드'가 20인 튜플만을 대상으로 한다.
	```


	- 문제의 SQL문은 DISTINCT가 "부서코드"에 적용되는 것이 아니라 `COUNT(부서코드)`에 적용됨에 유의해야 한다.
	- `WHERE 부서코드 = 20`: "부서코드"가 20인 자료만을 검색한다.

		| 부서코드  |
		| :---: |
		| 20             |
		| 20             |
		| 20             |

	- `SELECT DISTINCT COUNT(부서코드)`: `COUNT(부서코드)`의 결과인 3에는 중복된 값이 없으므로 3이 그대로 표시된다.

		| COUNT(부서코드)  |
		| :---: |
		| 3                     |


	\[ ② SQL 문 해설 \]


	```sql
	DELETE FROM '부서'
	-- <부서> 테이블에서 튜플을 삭제한다.
	WHERE '부서코드' = 20;
	-- '부서코드'가 20인 튜플만을 대상으로 한다.
	SELECT DISTINCT COUNT('부서코드') 
	-- '부서코드'의 개수를 표시하되, 표시된 개수 중 중복된 값은 한 번만 표시한다.
	FROM '직원';
	-- <직원> 테이블에서 검색한다.
	```


	- `DELETE FROM 부서 WHERE 부서코드 = 20;`: \<직원\> 테이블의 "부서코드"는 \<부서\> 테이블의 "부서코드"를 참조하고, \<부서\> 테이블의 "부서코드"가 삭제되면 이를 참조하는 \<직원\> 테이블의 모든 튜플도 같이 삭제되도록 정의되었으므로, DELETE문 수행 후의 \<부서\>와 \<직원\> 테이블은 다음과 같다.

		\<부서\>


		| 부서코드  | 부서명  |
		| :---: | :---: |
		| 10             | 영업부           |
		| 30             | 개발부           |


		\<직원\>


		| 직원코드  | 부서코드  | 직원명  |
		| :---: | :---: | :---: |
		| 1001           | 10             | 이진수           |
		| 1002           | 10             | 곽민경           |
		| 1006           | 30             | 박종일           |
		| 1007           | 30             | 박미경           |

	- `SELECT DISTINCT COUNT(부서코드) FROM 직원;`: \<직원\> 테이블에 대한 `COUNT(부서코드)`의 결과인 4에는 중복된 값이 없으므로 4가 그대로 표시된다.

		| COUNT(부서코드)  |
		| :---: |
		| 4                     |


	</details>

2. 학생(STUDENT) 테이블에 전기과 학생이 50명, 전산과 학생이 100명, 전자과 학생이 50명이 있다고 할 때, 다음 SQL문 ①, ②, ③의 실행 결과로 표시되는 튜플의 수를 쓰시오. (단, DEPT 필드는 학과를 의미한다.)

	<div class="callout">


	① SELECT DEPT FROM STUDENT;


	② SELECT DISTINCT DEPT FROM STUDENT;


	③ SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = "전산과";


	</div>


	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① 200


	② 3


	③ 1


	\[ ① 해설 \]


	```sql
	STUDENT DEPT
	-- 'DEPT'를 표시한다.
	FROM STUDENT;
	-- <STUDENT> 테이블을 대상으로 검색한다.
	```


	- \<STUDENT\> 테이블에서 "DEPT"를 검색한다.
	- 총 200개의 튜플이 들어있고 검색 조건이 없으므로 튜플의 수는 200이다.

	\[ ② 해설 \]


	```sql
	STUDENT DISTINCT DEPT
	-- 'DEPT'를 표시하되, 같은 "DEPT" 속성의 값은 한 번만 표시한다.
	FROM STUDENT;
	-- <STUDENT> 테이블을 대상으로 검색한다.
	```


	- \<STUDENT\> 테이블에서 "DEPT"를 검색하는 데 중복된 결과는 처음의 한 개만 검색에 포함시킨다.
	- 전기과 50개 튜플의 "DEPT" 속성의 값이 같으므로 1개, 전산과 100개 튜플의 "DEPT" 속성의 값이 같으므로 1개, 전자과 50개 튜플의 "DEPT" 속성의 값이 같으므로 1개를 검색에 포함시키므로 3개의 튜플이 검색된다.

	\[ ③ 해설 \]


	```sql
	SELECT COUNT(DISTINCT DEPT)
	-- "DEPT"의 개수를 표시하되, 같은 "DEPT" 속성의 값은 한 번만 계산한다.
	FROM STUDENT
	-- <STUDENT> 테이블을 대상으로 검색한다.
	WHERE DEPT = '전산과';
	-- "DEPT"가 "전산과"인 자료만을 대상으로 검색한다.
	```



	\<STUDENT\> 테이블에서 "DEPT" 속성의 값이 "전산과"인 튜플에 대해 중복을 제거하고 개수를 세므로 1이 검색 결과로 표시된다.


	</details>

3. 다음은 \<제품\>(제품명, 단가, 제조사) 테이블을 대상으로 "H" 제조사에서 생산한 제품들의 "단가"보다 높은 "단가"를 가진 제품의 정보를 조회하는 \<SQL문\>이다. 괄호에 알맞은 답을 적어 \<SQL문\>을 완성하시오.

	\<SQL문\>


	```sql
	SELECT '제품명', '단가', '제조사'
	FROM '제품'
	WHERE '단가' > ('    ') (SELECT '단가' FROM '제품' WHERE '제조사' = 'H');
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	ALL


	\[ 해설 \]


	```sql
	SELECT '제품명', '단가', '제조사' -- 2
	-- '제품명', '단가', '제조사' 속성을 표시한다.
	FROM '제품'
	-- <제품> 테이블에서 검색한다.
	WHERE '단가' > ALL
	-- '단가'가 하위 질의로 검색된 모든(ÅLL) 단가보다 큰 자료만을 대상으로 한다.
	(SELECT '단가' -- 1
	-- '단가'를 표시한다.
	FROM '제품'
	-- <제품> 테이블에서 검색한다.
	WHERE '제조사' = 'H');
	-- 제조사가 'H'인 자료만을 대상으로 한다.
	```


	- 문제의 질의문은 하위 질의가 있는 질의문이다.
	- 먼저 `WHERE` 조건에 지정된 하위 질의의 `SELECT`문을 해석한 다음 그 결과를 본 질의의 조건에 있는  "단가" 속성과 비교한다.
	- \<제품\> 테이블에 다음과 같은 자료가 들어있다고 가정하여 설명한다.

	\<제품\>


	| 제품명  | 단가  | 제조사  |
	| :---: | :---: | :---: |
	| 냉장고           | 200          | H             |
	| TV            | 150          | H             |
	| 세탁기           | 300          | H             |
	| 건조기           | 250          | A             |
	| 핸드폰           | 400          | B             |
	| 컴퓨터           | 500          | C             |

	1. \<제품\> 테이블에서 "제조사" 속성의 값이 "H"인 튜플의 "단가" 속성의 값을 검색한다.

		| 단가  |
		| :---: |
		| 200          |
		| 150          |
		| 300          |

	2. \<제품\> 테이블에서 "단가" 속성의 값이 1번에서 검색된 모든 단가보다 큰 자료를 대상으로 "제품명", "단가", "제조사"를 표시합니다.

		| 제품명  | 단가  | 제조사  |
		| :---: | :---: | :---: |
		| 핸드폰           | 400          | B             |
		| 컴퓨터           | 500          | C             |


	</details>

4. 다음 \<TABLE\>을 참조하여 \<SQL문\>을 실행했을 때 출력되는 결과를 쓰시오. (\<TABLE\>에 표시된 "NULL"은 값이 없음을 의미한다.)

	\<TABLE\>


	| INDEX  | COL1  | COL2  |
	| :---: | :---: | :---: |
	| 1               | 2              | NULL           |
	| 2               | 4              | 6              |
	| 3               | 3              | 5              |
	| 4               | 6              | 3              |
	| 5               | NULL           | 3              |


	\<SQL문\>


	```sql
	SELECT COUNT(COL2)
	FROM TABLE
	WHERE COL1 IN (2, 3)
		OR COL2 IN (3, 5);
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	3


	\[ 해설 \]


	```sql
	SELECT COUNT(COL2) -- 'COL2'의 개수를 표시한다.
	FROM TABLE -- <TABLE>에서 검색한다.
	WHERE COL1 IN (2, 3) -- 'COL1'이 2 또는 3이거나,
		OR COL2 IN (3, 5); -- 'COL2'이 3 또는 5인 튜플만을 대상으로 한다.
	```


	- 질의문의 조건을 만족하는 튜플은 다음과 같다.

		| INDEX  | COL1               | COL2               |
		| :---: | :---: | :---: |
		| <ins>1</ins>    | <ins>2</ins>                | <ins class="red">NULL</ins> |
		| 2               | 4                           | 6                           |
		| <ins>3</ins>    | <ins>3</ins>                | <ins>5</ins>                |
		| <ins>4</ins>    | <ins>6</ins>                | <ins>3</ins>                |
		| <ins>5</ins>    | <ins class="red">NULL</ins> | <ins>3</ins>                |

	- 조건에 맞는 "COL2" 속성만 추출하면 다음과 같다.

		| COL2               |
		| :---: |
		| <ins class="red">NULL</ins> |
		| <ins>5</ins>                |
		| <ins>3</ins>                |
		| <ins>3</ins>                |

	- `COUNT(COL2)`는 "COL2" 필드의 개수를 계산하지만 "NULL" 값은 제외하므로 `COUNT(COL2)`의 결과는 3이다.

	</details>

