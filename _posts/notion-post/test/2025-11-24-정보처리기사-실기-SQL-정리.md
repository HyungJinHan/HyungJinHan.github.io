---
title: 정보처리기사 실기 SQL 정리
description: 정보처리기사 실기 SQL 기출 문제 정리 (feat 시나공)
categories:
  - Computer Science
  - 정보처리기사
tags:
  - 정보처리기사
pin: false
math: true
mermaid: true
published: true
done: true
image-path: /assets/img/notion-post/test/정보처리기사-실기-SQL-정리
image:
  path: /assets/img/notion-post/test/정보처리기사-실기-SQL-정리/q-net.png
  lqip: data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=
  alt: 정보처리기사 실기 SQL 정리
date: '2025-11-24 07:48:00'
---



## SQL 기출 문제 정리


---



### SQL 명령문의 기본 형식과 조건

1. 다음과 같이 테이블을 정의하고 튜플을 삽입하였을 때 각 번호(①, ②)의 SQL문을 실행한 결과를 쓰시오.

	```sql
	CREATE TABLE '부서' (
		'부서코드' INT PRIMARY KEY,
		'부서명' VARCHAR(20)
	);
	
	CREATE TABLE '직원' (
		'직원코드' INT PRIMARY KEY,
		'부서코드' INT,
		'직원명' VARCHAR(20),
		FOREIGN KEY('부서코드') REFERENCES '부서'('부서코드')
			ON DELETE CASCADE
	);
	
	INSERT INTO '부서' VALUES(10, '영업부');
	INSERT INTO '부서' VALUES(20, '기획부');
	INSERT INTO '부서' VALUES(30, '개발부');
	
	INSERT INTO '직원' VALUES(1001, 10, '이진수');
	INSERT INTO '직원' VALUES(1002, 10, '곽연경');
	INSERT INTO '직원' VALUES(1003, 20, '김선길');
	INSERT INTO '직원' VALUES(1004, 20, '최민수');
	INSERT INTO '직원' VALUES(1005, 20, '이용갑');
	INSERT INTO '직원' VALUES(1006, 30, '박종일');
	INSERT INTO '직원' VALUES(1007, 30, '박미경');
	```



	①


	```sql
	SELECT DISTINCT COUNT('부서코드') FROM '직원' WHERE '부서코드' = 20;
	```



	②


	```sql
	DELETE FROM '부서' WHERE '부서코드' = 20;
	SELECT DISTINCT COUNT('부서코드') FROM '직원';
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① - 3


	② - 4


	\[ 해설 \]


	```sql
	CREATE TABLE '부서' (
	-- <부서 테이블을 생성한다.>
		'부서코드' INT PRIMARY KEY,
		-- '부서코드' 속성은 정수형이며, 기본키로 정의한다.
		'부서명' VARCHAR(20)
		-- '부서명' 속성은 가변길이 문자 20자이다.
	);
	
	CREATE TABLE '직원' (
	-- <직원> 테이블을 생성한다.
		'직원코드' INT PRIMARY KEY,
		-- '직원코드' 속성은 정수형이며, 기본키로 정의한다.
		'부서코드' INT,
		-- '부서코드' 속성은 정수형이다.
		'직원명' VARCHAR(20),
		-- '직원명' 속성은 가변길이 문자 20이다.
		FOREIGN KEY('부서코드') REFERENCES '부서'('부서코드')
		-- '부서코드' 속성은 <부서> 테이블의 '부서코드' 속성을 참조하는 외래키이다.
			ON DELETE CASCADE
			-- <부서> 테이블에서 튜플이 삭제되면 관련된 모든 튜플이 함께 삭제된다.
	);
	
	INSERT INTO '부서' VALUES(10, '영업부'); -- 1
	INSERT INTO '부서' VALUES(20, '기획부'); -- 2
	INSERT INTO '부서' VALUES(30, '개발부'); -- 3
	
	INSERT INTO '직원' VALUES(1001, 10, '이진수'); -- 4
	INSERT INTO '직원' VALUES(1002, 10, '곽연경'); -- 5
	INSERT INTO '직원' VALUES(1003, 20, '김선길'); -- 6
	INSERT INTO '직원' VALUES(1004, 20, '최민수'); -- 7
	INSERT INTO '직원' VALUES(1005, 20, '이용갑'); -- 8
	INSERT INTO '직원' VALUES(1006, 30, '박종일'); -- 9
	INSERT INTO '직원' VALUES(1007, 30, '박미경'); -- 10
	```


	- 1 ~ 3번 SQL문이 수행된 후 \<부서\> 테이블은 다음과 같다.

		\<부서\>


		| 부서코드  | 부서명  |
		| :---: | :---: |
		| 10             | 영업부           |
		| 20             | 기획부           |
		| 30             | 개발부           |

	- 4 ~ 10번 SQL문이 수행된 후 \<직원\> 테이블은 다음과 같다.

		\<직원\>


		| 직원코드  | 부서코드  | 직원명  |
		| :---: | :---: | :---: |
		| 1001           | 10             | 이진수           |
		| 1002           | 10             | 곽연경           |
		| 1003           | 20             | 김선길           |
		| 1004           | 20             | 최민수           |
		| 1005           | 20             | 이용갑           |
		| 1006           | 30             | 박종일           |
		| 1007           | 30             | 박미경           |


	\[ ① SQL 문 해설 \]


	```sql
	SELECT DISTINCT COUNT('부서코드')
	-- '부서코드'의 개수를 표시하되, 표시된 개수 중 중복된 값은 한 번만 표시한다.
	FROM '직원'
	-- <직원> 테이블에서 검색한다.
	WHERE '부서코드' = 20;
	-- '부서코드'가 20인 튜플만을 대상으로 한다.
	```


	- 문제의 SQL문은 DISTINCT가 "부서코드"에 적용되는 것이 아니라 `COUNT(부서코드)`에 적용됨에 유의해야 한다.
	- `WHERE 부서코드 = 20`: "부서코드"가 20인 자료만을 검색한다.

		| 부서코드  |
		| :---: |
		| 20             |
		| 20             |
		| 20             |

	- `SELECT DISTINCT COUNT(부서코드)`: `COUNT(부서코드)`의 결과인 3에는 중복된 값이 없으므로 3이 그대로 표시된다.

		| COUNT(부서코드)  |
		| :---: |
		| 3                     |


	\[ ② SQL 문 해설 \]


	```sql
	DELETE FROM '부서'
	-- <부서> 테이블에서 튜플을 삭제한다.
	WHERE '부서코드' = 20;
	-- '부서코드'가 20인 튜플만을 대상으로 한다.
	SELECT DISTINCT COUNT('부서코드') 
	-- '부서코드'의 개수를 표시하되, 표시된 개수 중 중복된 값은 한 번만 표시한다.
	FROM '직원';
	-- <직원> 테이블에서 검색한다.
	```


	- `DELETE FROM 부서 WHERE 부서코드 = 20;`: \<직원\> 테이블의 "부서코드"는 \<부서\> 테이블의 "부서코드"를 참조하고, \<부서\> 테이블의 "부서코드"가 삭제되면 이를 참조하는 \<직원\> 테이블의 모든 튜플도 같이 삭제되도록 정의되었으므로, DELETE문 수행 후의 \<부서\>와 \<직원\> 테이블은 다음과 같다.

		\<부서\>


		| 부서코드  | 부서명  |
		| :---: | :---: |
		| 10             | 영업부           |
		| 30             | 개발부           |


		\<직원\>


		| 직원코드  | 부서코드  | 직원명  |
		| :---: | :---: | :---: |
		| 1001           | 10             | 이진수           |
		| 1002           | 10             | 곽민경           |
		| 1006           | 30             | 박종일           |
		| 1007           | 30             | 박미경           |

	- `SELECT DISTINCT COUNT(부서코드) FROM 직원;`: \<직원\> 테이블에 대한 `COUNT(부서코드)`의 결과인 4에는 중복된 값이 없으므로 4가 그대로 표시된다.

		| COUNT(부서코드)  |
		| :---: |
		| 4                     |


	</details>

2. 학생(STUDENT) 테이블에 전기과 학생이 50명, 전산과 학생이 100명, 전자과 학생이 50명이 있다고 할 때, 다음 SQL문 ①, ②, ③의 실행 결과로 표시되는 튜플의 수를 쓰시오. (단, DEPT 필드는 학과를 의미한다.)

	<div class="callout">


	① SELECT DEPT FROM STUDENT;


	② SELECT DISTINCT DEPT FROM STUDENT;


	③ SELECT COUNT(DISTINCT DEPT) FROM STUDENT WHERE DEPT = "전산과";


	</div>


	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① 200


	② 3


	③ 1


	\[ ① 해설 \]


	```sql
	STUDENT DEPT
	-- 'DEPT'를 표시한다.
	FROM STUDENT;
	-- <STUDENT> 테이블을 대상으로 검색한다.
	```


	- \<STUDENT\> 테이블에서 "DEPT"를 검색한다.
	- 총 200개의 튜플이 들어있고 검색 조건이 없으므로 튜플의 수는 200이다.

	\[ ② 해설 \]


	```sql
	STUDENT DISTINCT DEPT
	-- 'DEPT'를 표시하되, 같은 "DEPT" 속성의 값은 한 번만 표시한다.
	FROM STUDENT;
	-- <STUDENT> 테이블을 대상으로 검색한다.
	```


	- \<STUDENT\> 테이블에서 "DEPT"를 검색하는 데 중복된 결과는 처음의 한 개만 검색에 포함시킨다.
	- 전기과 50개 튜플의 "DEPT" 속성의 값이 같으므로 1개, 전산과 100개 튜플의 "DEPT" 속성의 값이 같으므로 1개, 전자과 50개 튜플의 "DEPT" 속성의 값이 같으므로 1개를 검색에 포함시키므로 3개의 튜플이 검색된다.

	\[ ③ 해설 \]


	```sql
	SELECT COUNT(DISTINCT DEPT)
	-- "DEPT"의 개수를 표시하되, 같은 "DEPT" 속성의 값은 한 번만 계산한다.
	FROM STUDENT
	-- <STUDENT> 테이블을 대상으로 검색한다.
	WHERE DEPT = '전산과';
	-- "DEPT"가 "전산과"인 자료만을 대상으로 검색한다.
	```



	\<STUDENT\> 테이블에서 "DEPT" 속성의 값이 "전산과"인 튜플에 대해 중복을 제거하고 개수를 세므로 1이 검색 결과로 표시된다.


	</details>

3. 다음은 \<제품\>(제품명, 단가, 제조사) 테이블을 대상으로 "H" 제조사에서 생산한 제품들의 "단가"보다 높은 "단가"를 가진 제품의 정보를 조회하는 \<SQL문\>이다. 괄호에 알맞은 답을 적어 \<SQL문\>을 완성하시오.

	\<SQL문\>


	```sql
	SELECT '제품명', '단가', '제조사'
	FROM '제품'
	WHERE '단가' > ('    ') (SELECT '단가' FROM '제품' WHERE '제조사' = 'H');
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	ALL


	\[ 해설 \]


	```sql
	SELECT '제품명', '단가', '제조사' -- 2
	-- '제품명', '단가', '제조사' 속성을 표시한다.
	FROM '제품'
	-- <제품> 테이블에서 검색한다.
	WHERE '단가' > ALL
	-- '단가'가 하위 질의로 검색된 모든(ÅLL) 단가보다 큰 자료만을 대상으로 한다.
	(SELECT '단가' -- 1
	-- '단가'를 표시한다.
	FROM '제품'
	-- <제품> 테이블에서 검색한다.
	WHERE '제조사' = 'H');
	-- 제조사가 'H'인 자료만을 대상으로 한다.
	```


	- 문제의 질의문은 하위 질의가 있는 질의문이다.
	- 먼저 `WHERE` 조건에 지정된 하위 질의의 `SELECT`문을 해석한 다음 그 결과를 본 질의의 조건에 있는  "단가" 속성과 비교한다.
	- \<제품\> 테이블에 다음과 같은 자료가 들어있다고 가정하여 설명한다.

	\<제품\>


	| 제품명  | 단가  | 제조사  |
	| :---: | :---: | :---: |
	| 냉장고           | 200          | H             |
	| TV            | 150          | H             |
	| 세탁기           | 300          | H             |
	| 건조기           | 250          | A             |
	| 핸드폰           | 400          | B             |
	| 컴퓨터           | 500          | C             |

	1. \<제품\> 테이블에서 "제조사" 속성의 값이 "H"인 튜플의 "단가" 속성의 값을 검색한다.

		| 단가  |
		| :---: |
		| 200          |
		| 150          |
		| 300          |

	2. \<제품\> 테이블에서 "단가" 속성의 값이 1번에서 검색된 모든 단가보다 큰 자료를 대상으로 "제품명", "단가", "제조사"를 표시합니다.

		| 제품명  | 단가  | 제조사  |
		| :---: | :---: | :---: |
		| 핸드폰           | 400          | B             |
		| 컴퓨터           | 500          | C             |


	</details>

4. 다음 \<TABLE\>을 참조하여 \<SQL문\>을 실행했을 때 출력되는 결과를 쓰시오. (\<TABLE\>에 표시된 "NULL"은 값이 없음을 의미한다.)

	\<TABLE\>


	| INDEX  | COL1  | COL2  |
	| :---: | :---: | :---: |
	| 1               | 2              | NULL           |
	| 2               | 4              | 6              |
	| 3               | 3              | 5              |
	| 4               | 6              | 3              |
	| 5               | NULL           | 3              |


	\<SQL문\>


	```sql
	SELECT COUNT(COL2)
	FROM TABLE
	WHERE COL1 IN (2, 3)
		OR COL2 IN (3, 5);
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	3


	\[ 해설 \]


	```sql
	SELECT COUNT(COL2) -- 'COL2'의 개수를 표시한다.
	FROM TABLE -- <TABLE>에서 검색한다.
	WHERE COL1 IN (2, 3) -- 'COL1'이 2 또는 3이거나,
		OR COL2 IN (3, 5); -- 'COL2'이 3 또는 5인 튜플만을 대상으로 한다.
	```


	- 질의문의 조건을 만족하는 튜플은 다음과 같다.

		| INDEX            | COL1               | COL2               |
		| :---: | :---: | :---: |
		| <ins class="blue">1</ins> | <ins class="blue">2</ins>   | <ins class="red">NULL</ins> |
		| 2                         | 4                           | 6                           |
		| <ins class="blue">3</ins> | <ins class="blue">3</ins>   | <ins class="blue">5</ins>   |
		| <ins class="blue">4</ins> | <ins class="blue">6</ins>   | <ins class="blue">3</ins>   |
		| <ins class="blue">5</ins> | <ins class="red">NULL</ins> | <ins class="blue">3</ins>   |

	- 조건에 맞는 "COL2" 속성만 추출하면 다음과 같다.

		| COL2               |
		| :---: |
		| <ins class="red">NULL</ins> |
		| <ins class="blue">5</ins>   |
		| <ins class="blue">3</ins>   |
		| <ins class="blue">3</ins>   |

	- `COUNT(COL2)`는 "COL2" 필드의 개수를 계산하지만 "NULL" 값은 제외하므로 `COUNT(COL2)`의 결과는 3이다.

	</details>

5. 다음은 \<EMPLOYEE\> 릴레이션에 대해 \<관계 대수식\>을 수행했을 때 출력되는 \<결과\>이다. \<결과\>의 각 괄호(① ~ ⑤)에 들어갈 알맞은 답을 쓰시오.

	\<관계 대수식\>


	<div class="callout">


	$𝛑_{TTL}(EMPLOYEE)$


	</div>


	\<EMPLOYEE\>


	| INDEX  | AGE  | TTL  |
	| :---: | :---: | :---: |
	| 1               | 48            | 부장            |
	| 2               | 25            | 대리            |
	| 3               | 41            | 과장            |
	| 4               | 36            | 차장            |


	↓


	\<결과\>


	| (<span class="blank">①</span>)  |
	| :---: |
	| (<span class="blank">②</span>)           |
	| (<span class="blank">③</span>)           |
	| (<span class="blank">④</span>)           |
	| (<span class="blank">⑤</span>)           |


	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① TTL


	② 부장


	③ 대리


	④ 과장


	⑤ 차장


	<div class="callout">


	\[ 해설 \]


	문제의 \<관계 대수식\>에서 사용된 𝛑는 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 PROJECT 연산이므로, \<EMPLOYEE\> 릴레이션에서 "TTL" 속성이 추출되어 속성명인 "TTL"부터 모든 속성값이 \<결과\>로 나타난다.


	</div>


	</details>

6. SQL과 관련한 다음 설명에서 괄호(①, ②)에 들어갈 알맞은 답을 쓰시오.

	UPDATE문은 테이블에 있는 튜플의 내용을 갱신할 때 사용하는 명령문으로, DML에 해당한다. 다른 DML로는 INSERT, DELETE가 있으며, 각각 새로운 튜플을 삽입하거나 삭제할 때 사용한다.


	\<학부생\> 테이블


	| 학부  | 학과번호  | 입학생수  | 담당관  |
	| :---: | :---: | :---: | :---: |
	| 정경대학         | 110            | 300            | 김해율           |
	| 공과대학         | 310            | 250            | 이성관           |
	| 인문대학         | 120            | 400            | 김해율           |
	| 정경대학         | 120            | 300            | 김성수           |
	| 인문대학         | 420            | 180            | 이율해           |


	다음은 \<학부생\> 테이블에서 "입학생수"가 300 이상인 튜플의 "학과번호"를 999로 갱신하는 SQL문이다.


	```sql
	('   ①   ') '학부생' ('   ②   ') '학과번호' = 999 WHERE '입학생수' >= 300;
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① UPDATE


	② SET


	\[ 해설 \]

	- SQL문

		```sql
		UPDATE '학부생' -- '학부생' 테이블을 갱신하라.
		SET '학과번호' = 999 -- '학과번호'를 999로 갱신하라.
		WHERE '입학생수' >= 300; -- '입학생수'가 300이상인 튜플만을 대상으로 하라.
		```


	- SQL 실행 결과

		| 학부                  | 학과번호               | 입학생수               | 담당관                |
		| :---: | :---: | :---: | :---: |
		| <ins class="blue">정경대학</ins> | <ins class="blue">999</ins> | <ins class="blue">300</ins> | <ins class="blue">김해율</ins> |
		| 공과대학                         | 310                         | 250                         | 이성관                         |
		| <ins class="blue">인문대학</ins> | <ins class="blue">999</ins> | <ins class="blue">400</ins> | <ins class="blue">김해율</ins> |
		| <ins class="blue">정경대학</ins> | <ins class="blue">999</ins> | <ins class="blue">300</ins> | <ins class="blue">김성수</ins> |
		| 인문대학                         | 420                         | 180                         | 이율해                         |


	</details>

7. \<EMP_TBL\> 테이블 참고하여 \<SQL문\>의 실행 결과를 쓰시오.

	\<EMP_TBL\>


	| EMPNO  | SAL  |
	| :---: | :---: |
	| 100             | 1500          |
	| 200             | 3000          |
	| 300             | 2000          |


	\<SQL문\>


	```sql
	SELECT COUNT(*) FROM EMP_TBL WHERE EMPNO > 100 AND SAL >= 3000 OR EMPNO = 200;
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	1


	\[ 해설 \]


	SQL도 프로그래밍 언어와 마찬가지로 OR 연산자에 비해 AND 연산자의 우선순위가 높다. 즉 <ins>식1 AND 식2 OR 식3</ins>과 같이 조건이 제시된 경우 <ins>식1 AND 식2</ins>의 조건을 먼저 확인한 후 그 결과와 식3의 OR 조건을 확인해야 한다.


	```sql
	SELECT COUNT(*) FROM EMP_TBL -- 튜플의 개수를 표시한다.
	WHERE EMPNO > 100 -- <EMP_TBL> 테이블에서 검색한다.
		AND SAL >= 3000 -- 'SAL'이 3000 이상이거나,
		OR EMPNO = 200; -- 'EMPNO'가 200인 튜플만을 대상으로 한다.
	```



	\<과정\>

	1. "EMPNO"가 100보다 큰 튜플은 다음과 같다.

		| EMPNO  | SAL  |
		| :---: | :---: |
		| 200             | 3000          |
		| 300             | 2000          |

	2. "SAL"이 3000 이상인 튜플은 다음과 같다.

		| EMPNO  | SAL  |
		| :---: | :---: |
		| 200             | 3000          |

	3. 1번과 2번의 조건을 동시에 만족(AND)하는 튜플은 다음과 같다.

		| EMPNO  | SAL  |
		| :---: | :---: |
		| 200             | 3000          |

	4. "EMPNO"가 200인 튜플은 다음과 같다.

		| EMPNO  | SAL  |
		| :---: | :---: |
		| 200             | 3000          |

	5. 3번 또는 4번의 튜플 중 한 번이라도 포함된(OR) 튜플은 다음과 같다.

		| EMPNO  | SAL  |
		| :---: | :---: |
		| 200             | 3000          |

	6. `COUNT(*)` 함수에 따라 5번 튜플의 개수를 표시하면 다음과 같다.

		| COUNT(*)  |
		| :---: |
		| 1                  |


	</details>

8. \<학생\> 테이블에서 "이름"이 "민수"인 투플을 삭제하고자 한다. 다음 \<처리 조건\>을 참고하여 SQL문을 작성하시오.

	\<처리 조건\>


	<div class="callout">

	- 명령문 마지막의 세미콜론(`;`)은 생략이 가능하다.
	- 인용 부호가 필요한 경우 작은따옴표 (`' '`)를 사용한다.

	</div>


	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	```sql
	DELETE FROM '학생' WHERE '이름' = '민수';
	```



	\[ 해설 \]


	```sql
	DELETE -- 삭제하라.
	FROM '학생' -- <학생> 테이블을 대상으로 하라.
	WHERE '이름' = '민수'; -- '이름'이 '민수'인 자료만을 대상으로 한다.
	```



	</details>

9. 다음 \<속성 정의서\>를 참고하여 \<학생\> 테이블에 대해 20자의 가변 길이를 가진 "주소" 속성을 추가하는 \<SQL문\>을 완성하시오. (단, SQL문은 ISO/IEC 9075 표준을 기반으로 작성하시오.)

	\<속성 정의서\>


	| 속성명  | 데이터타입  | 제약조건  | 테이블명  |
	| :---: | :---: | :---: | :---: |
	| 학번            | CHAR(10)        | UNIQUE         | 학생             |
	| 이름            | VARCHAR(8)      | NOT NULL       | 학생             |
	| 주민번호          | CHAR(13)        |                | 학생             |
	| 학과            | VARCHAR(16)     | FOREIGN KEY    | 학생             |
	| 학년            | INT             |                | 학생             |


	\<SQL문\>


	```sql
	 ('   ①   ') TABLE '학생' ('   ②   ') '주소' VARCHAR(20);
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① ALTER


	② ADD


	\[ 해설 \]


	```sql
	ALTER TABLE '학생' -- 수정할 테이블의 이름은 <학생>이다.
	ADD '주소' VARCHAR(20); -- 가변 길이의 문자 20자리인 '주소' 속성을 추가한다.
	```



	</details>

10. 다음 \<학생\> 테이블을 참고하여 \<처리 조건\>에서 요구하는 SQL문을 작성하시오.

	\<학생\>


	| 학번<br/>(varchar)  | 이름<br/>(varchar)  | 학년<br/>(varchar)  | 수강과목<br/>(varchar)  | 점수<br/>(varchar)  | 연락처<br/>(varchar)  |
	| :---: | :---: | :---: | :---: | :---: | :---: |
	| 20E0232                    | 김인영                        | 3                          | 세무행정                         | 4.5                        | 010-5412-4544               |
	| 19D0024                    | 이성화                        | 2                          | 토목개론                         | 3                          | 010-1548-4796               |
	| 20E0135                    | 성유수                        | 4                          | 실용법학                         | 3.5                        | 010-9945-7411               |
	| 20E0511                    | 우인혁                        | 1                          | 데이터론                         | 2                          | 010-3451-4972               |


	\<처리 조건\>


	<div class="callout">

	- 3, 4학년의 학번, 이름을 조회한다.
	- IN 예약어를 사용해야 한다.
	- 속성명 아래의 괄호는 속성의 자료형을 의미한다.

	</div>


	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	```sql
	SELECT '학번', '이름' FROM '학생' WHERE '학년' IN (3, 4);
	```



	\[ 해설 \]


	```sql
	SELECT '학번', '이름' -- '학번', '이름'을 표시한다.
	FROM '학생' -- <학생> 테이블에서 검색한다.
	WHERE '학년' IN (3, 4); -- '학년'의 값이 3 또는 4인 자료만을 대상으로 한다.
	```



	\<결과\>


	| 학번  | 이름  |
	| :---: | :---: |
	| 20E0232      | 김인영          |
	| 20E0135      | 성유수          |


	</details>

11. 다음 \<student\> 테이블을 참고하여 "name" 속성으로 "idx_name"이라는 인덱스를 생성하는 SQL문을 작성하시오.

	\<student\>


	| stid  | name  | score  | deptid  |
	| :---: | :---: | :---: | :---: |
	| 2001           | brown          | 85              | PE01             |
	| 2002           | white          | 45              | EF03             |
	| 2003           | black          | 67              | UW11             |


	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	```sql
	CREATE INDEX idx_name ON student(name);
	```



	\[ 해설 \]


	```sql
	CREATE INDEX idx_name -- 'idx_name'이라는 이름의 인덱스를 생성한다.
	ON student(name); -- <student> 테이블의 'name' 속성을 사용한다.
	```



	</details>

12. 다음은 \<성적\> 테이블에서 이름(name)과 점수(score)를 조회하되, 점수를 기준으로 내림차순 정렬하여 조회하는 \<SQL문\>이다. 괄호(① ~ ③)에 알맞은 답을 적어 \<SQL문\>을 완성하시오.

	\<성적\>


	| name  | class  | score  |
	| :---: | :---: | :---: |
	| 정기찬            | A               | 85              |
	| 이영호            | C               | 74              |
	| 환정형            | C               | 95              |
	| 김지수            | A               | 90              |
	| 최은영            | B               | 82              |


	\<SQL문\>


	```sql
	SELECT name, score
	FROM '성적'
	('   ①   ') BY ('   ②   ') ('   ③   ')
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① ORDER


	② score


	③ DESC


	\[ 해설 \]


	```sql
	SELECT name, score -- 'name'과 'score'를 표시한다.
	FROM '성적' -- <성적> 테이블에서 검색한다.
	('   ①   ') BY ('   ②   ') ('   ③   ') -- 'score'를 기준으로 내림차순 정렬한다.
	```



	</details>

13. 다음은 \<회원\> 테이블에서 "이름"이 "이"로 시작하는 회원들을 "가입일" 순으로 내림차순 정렬하는 \<SQL문\>이다. 괄호(①, ②)에 들어갈 알맞은 답을 쓰시오.

	\<회원\> 테이블


	| <u>회원번호</u>  | 이름  | 성별  | 가입일  |
	| :---: | :---: | :---: | :---: |
	| 1001                  | 이진성          | 남            | 2021-06-23    |
	| 1002                  | 조이령          | 여            | 2021-06-24    |
	| 1003                  | 최민수          | 남            | 2021-06-28    |
	| 1004                  | 김차희          | 여            | 2021-07-03    |
	| 1005                  | 이미경          | 여            | 2021-07-10    |


	\<SQL문\>


	```sql
	SELECT * FROM '회원' WHERE '이름' LIKE ('  ①  ') ORDER BY '가입일' ('  ②  ');
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① 이%


	② DESC


	\[ 해설 \]

	- SQL문

		```sql
		SELECT * -- 모든 속성을 표시한다.
		FROM '회원' -- <회원> 테이블에서 검색한다.
		WHERE '이름' LIKE '이%' -- '이름'이 '이'로 시작하는 튜플만을 대상으로 한다.
		ORDER BY '가입일' DESC; -- '가입일'을 기준으로 내림차순 정렬한다.
		```


	- SQL 실행 결과

		| 회원번호  | 이름  | 성별  | 가입일  |
		| :---: | :---: | :---: | :---: |
		| 1005           | 이미경          | 여            | 2021-07-10    |
		| 1001           | 이진성          | 남            | 2021-06-23    |


	</details>

14. 다음 질의 내용에 대한 SQL문을 완성하시오.

	<div class="callout">


	\[ 질의 \]


	학생 테이블에서 학과별 튜플의 개수를 검색하시오.


	(단, 아래의 실행 결과가 되도록 한다.)


	</div>


	\<학생\>


	| 학번  | 이름  | 학년  | 학과  | 주소  |
	| :---: | :---: | :---: | :---: | :---: |
	| 20160011     | 김영란          | 2            | 전기           | 서울           |
	| 19210113     | 이재우          | 3            | 컴퓨터          | 대구           |
	| 21168007     | 함소진          | 1            | 전자           | 부산           |
	| 19168002     | 우혜정          | 3            | 전자           | 광주           |
	| 18120073     | 김진수          | 4            | 컴퓨터          | 울산           |


	\<실행결과\>


	| 학과  | 학과별튜플수  |
	| :---: | :---: |
	| 전기           | 1                |
	| 컴퓨터          | 2                |
	| 전자           | 2                |


	\<처리 조건\>


	<div class="callout">

	- WHERE 조건절은 사용할 수 없다.
	- GROUP BY는 반드시 포함한다.
	- 집계함수(Aggregation Function)를 적용한다.
	- 학과별튜플수 컬럼이름 출력에 Alias(AS)를 활용한다.
	- 문장 끝의 세미콜론(`;`)은 생략해도 무방하다.
	- 인용부호 사용이 필요한 경우 단일 따옴표(`' '`: Single Quotation)를 사용한다.

	</div>


	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	```sql
	SELECT '학과', COUNT(*) AS '학과별튜플수' FROM '학생' GROUP BY '학과';
	```



	\[ 해설 \]


	```sql
	SELECT '학과', COUNT(*) -- '학과'와 개수를 표시하되, 
	AS '학과별튜플수' -- 개수의 필드명을 '학과별튜플수'로 표시한다.
	FROM '학생' -- <학생> 테이블을 대상으로 검색한다.
	GROUP BY '학과'; -- '학과'를 기준으로 그룹을 지정한다.
	```



	</details>

15. 다음의 \<성적\> 테이블에서 과목별 점수의 평균이 90점 이상인 "과목이름", "최소점수", "최대점수"를 검색하고자 한다. \<처리 조건\>을 참고하여 적합한 SQL문을 작성하시오.

	\<성적\>


	| 학번  | 과목번호  | 과목이름  | 학점  | 점수  |
	| :---: | :---: | :---: | :---: | :---: |
	| a2001        | 101            | 컴퓨터구조          | 6            | 95           |
	| a2002        | 101            | 컴퓨터구조          | 6            | 84           |
	| a2003        | 302            | 데이터베이스         | 5            | 89           |
	| a2004        | 201            | 인공지능           | 5            | 92           |
	| a2005        | 302            | 데이터베이스         | 5            | 100          |
	| a2006        | 302            | 데이터베이스         | 5            | 88           |
	| a2007        | 201            | 인공지능           | 5            | 93           |


	\<결과\>


	| 과목이름  | 최소점수  | 최대점수  |
	| :---: | :---: | :---: |
	| 데이터베이스         | 88             | 100            |
	| 인공지능           | 92             | 93             |


	\<처리 조건\>


	<div class="callout">

	- WHERE문은 사용하지 않는다.
	- GROUP BY와 HAVING을 이용한다.
	- 집계함수(Aggregation Function)를 사용하여 명령문을 구성한다.
	- "최소점수", "최대점수"는 별칭(Alias)을 위한 AS문을 이용한다.
	- 명령문 마지막의 세미콜론(`;`)은 생략이 가능하다.
	- 인용 부호가 필요한 경우 작은따옴표(`' '`)를 사용한다.

	</div>


	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	```sql
	SELECT '과목이름', MIN('점수') AS '최소점수', MAX('점수') AS '최대점수' FROM '성적' GROUP BY '과목이름' HAVING AVG('점수') >= 90;
	```



	\[ 해설 \]


	```sql
	SELECT '과목이름', MIN('점수') AS '최소점수', MAX('점수') AS '최대점수' -- 1
	FROM '성적' -- 2
	GROUP BY '과목이름' -- 3
	HAVING AVG('점수') >= 90; -- 4
	```


	1. "과목이름", "점수"의 최소값, "점수"의 최대값을 표시하되, "점수"의 최소값은 "최소점수"로, "점수"의 최대값은 "최대점수"로 표시한다.
	2. \<성적\> 테이블을 대상으로 검색한다.
	3. "과목이름"을 기준으로 그룹을 지정한다.
	4. 각 그룹별 "점수"의 평균이 90보다 크거나 같은 그룹만을 표시한다.

	</details>

16. \<A\> 테이블과 \<B\> 테이블을 참고하여 \<SQL문\>의 실행 결과를 쓰시오.

	\<A\>


	| NAME  |
	| :---: |
	| Smith          |
	| Allen          |
	| Scott          |


	\<B\>


	| RULE  |
	| :---: |
	| S%             |
	| %T%            |


	\<SQL문\>


	```sql
	SELECT COUNT(*) CNT FROM A CROSS JOIN B WHERE A.NAME LIKE B.RULE;
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	4


	\[ 해설 \]


	```sql
	SELECT COUNT(*) CNT
	FROM A CROSS JOIN B
	WHERE A.NAME LIKE B.RULE;
	```


	1. `SELECT COUNT(*) CNT`
		- 튜플의 개수를 표시하되, 필드명은 `CNT`로 표시한다.
		- `SELECT COUNT(*) AS CNT`에서 `AS`가 생략된 형태
	2. `FROM A CROSS JOIN B`
		- \<A\>와 \<B\>를 교차 조인(`CROSS JOIN`)한 결과를 대상으로 검색한다.

			| A.NAME  | B.RULE  |
			| :---: | :---: |
			| Smith            | S%               |
			| Smith            | %T%              |
			| Allen            | S%               |
			| Allen            | %T%              |
			| Scott            | S%               |
			| Scott            | %T%              |

	3. `WHERE A.NAME LIKE B.RULE`
		- \<A\> 테이블의 `NAME` 필드 값이 \<B\> 테이블의 `RULE` 필드에 저장된 문자열 패턴과 일치하는 튜플만을 대상으로 한다.
		- \<B\> 테이블의 `RULE` 필드에 저장된 값은 `S%`와 `%T%`와 같이 문자 패턴인 `%` 기호가 포함되어 있으므로, 조건문의 `LIKE` 연산자와 결합되면 다음과 같이 적용된다.
		- `A.NAME LIKE S%`
			- `A.NAME`이 `S`로 시작하는 레코드를 검색

				| NAME                 | RULE               |
				| :---: | :---: |
				| <ins class="blue">Smith</ins> | <ins class="blue">S%</ins>  |
				| <ins class="blue">Smith</ins> | <ins class="blue">%T%</ins> |
				| Allen                         | S%                          |
				| Allen                         | %T%                         |
				| <ins class="blue">Scott</ins> | <ins class="blue">S%</ins>  |
				| <ins class="blue">Scott</ins> | <ins class="blue">%T%</ins> |

		- `A.NAME LIKE %T%`
			- `A.NAME`이 `T`를 포함하는 레코드를 검색

				| NAME                 | RULE               |
				| :---: | :---: |
				| <ins class="blue">Smith</ins> | <ins class="blue">S%</ins>  |
				| <ins class="blue">Smith</ins> | <ins class="blue">%T%</ins> |
				| Allen                         | S%                          |
				| Allen                         | %T%                         |
				| <ins class="blue">Scott</ins> | <ins class="blue">S%</ins>  |
				| <ins class="blue">Scott</ins> | <ins class="blue">%T%</ins> |

		- `CROSS JOIN`된 결과에서 조건을 만족하는 튜플은 다음과 같다. 그러므로 검색된 튜플의 개수는 <ins>4</ins>이다.

			| NAME  | RULE  |
			| :---: | :---: |
			| Smith          | S%             |
			| Smith          | %T%            |
			| Scott          | S%             |
			| Scott          | %T%            |


	</details>

17. 다음 \<사원\> 테이블과 \<동아리\> 테이블을 조인(JOIN)한 \<결과\>를 확인하여 \<SQL문\>의 괄호(①, ②)에 들어갈 알맞은 답을 쓰시오.

	| \<사원\> {.center} | {.center} | {.center} | <code class='language-plaintext highlighter-rouge'>|</code> | \<동아리\> {.center} | {.center} |
	| ---------------- | --------- | --------- | ----------------------------------------------------------- | ----------------- | --------- |
	| <u>코드</u>        | 이름        | 부서        | <code class='language-plaintext highlighter-rouge'>|</code> | <u>코드</u>         | 동아리명      |
	| 1601             | 김명해       | 인사        | <code class='language-plaintext highlighter-rouge'>|</code> | 1601              | 테니스       |
	| 1602             | 이진성       | 경영지원      | <code class='language-plaintext highlighter-rouge'>|</code> | 1731              | 탁구        |
	| 1731             | 박영광       | 개발        | <code class='language-plaintext highlighter-rouge'>|</code> | 2001              | 볼링        |
	| 2001             | 이수진       |           | <code class='language-plaintext highlighter-rouge'>|</code> |                   |           |


	↓


	\<결과\>


	| <u>코드</u>  | 이름  | 동아리명  |
	| :---: | :---: | :---: |
	| 1601                | 김명해          | 테니스            |
	| 1602                | 이진성          |                |
	| 1731                | 박영광          | 탁구             |
	| 2001                | 이수진          | 볼링             |


	\<SQL문\>


	```sql
	SELECT a.'코드', '이름', '동아리명' FROM '사원' a LEFT JOIN '동아리' b ('  ①  ') a.'코드' = b.('  ②  ');
	```



	<details>


	<summary markdown="span"><ins>답 확인하기</ins></summary>


	① ON


	② 코드


	\[ 해설 \]


	```sql
	SELECT a.'코드', '이름', '동아리명' -- 1
	FROM '사원' a LEFT JOIN '동아리' b -- 2
	ON a.'코드' = b.'코드'; -- 3
	```


	1. `a`가 가리키는 \<사원\> 테이블의 `코드`와 `이름`, `동아리명`을 표시한다.
	2. `LEFT JOIN`이므로, 좌측의 \<사원\> 테이블이 기준이 되어 \<사원\> 테이블에 있는 튜플은 모두 표시하고, 우측의 \<동아리\> 테이블에서는 관련이 있는 튜플만 표시한다.
		- \<사원\>, \<동아리\> 테이블의 별칭으로 \<a\>, \<b\>를 지정하고, \<a\>는 \<사원\> 테이블을, \<b\>는 \<동아리\> 테이블을 가리키게 된다.
	3. \<사원\> 테이블의 `코드`와 \<동아리\> 테이블의 `코드`를 기준으로 서로 `JOIN`한다.

	</details>

